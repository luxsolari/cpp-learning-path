; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32215.0 

	TITLE	D:\data\code\gaming-studio-practices\ThreadsMulti\bin\Win32\Debug\intermediates\castingSafu.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__6857C8E5_ThreadsMulti@pch DB 01H
__BB16330F_corecrt_math@h DB 01H
__2258C6CF_algorithm DB 01H
__491A2F6F_system_error DB 01H
__41DABE46_stdexcept DB 01H
__744010DC_xlocinfo DB 01H
__6BC9F314_typeinfo DB 01H
__8A79911F_vcruntime_typeinfo@h DB 01H
__BB00C2DC_pch@cpp DB 01H
__C159205C_memory DB 01H
__C1EC35D3_stdio@h DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__CA69427B_xlocnum DB 01H
__E7D4A097_ios DB 01H
__0ABAB74D_iterator DB 01H
__4DA567CF_xiosbase DB 01H
__54EE246C_xlocale DB 01H
__ED1C7753_xfacet DB 01H
__47FEFEA8_ostream DB 01H
__437A06FA_streambuf DB 01H
__242ECB92_istream DB 01H
__6EE2661F_initializer_list DB 01H
__305A5C32_vector DB 01H
__9596B502_utility DB 01H
__7DF72CD2_limits DB 01H
__C894841B_exception DB 01H
__DFFE99FD_vcruntime_exception@h DB 01H
__1F1E5892_type_traits DB 01H
__EBA563F3_vcruntime_new@h DB 01H
__1B16000D_xutility DB 01H
__62892210_xstddef DB 01H
__FF03D6C1_xmemory DB 01H
__8BD0505D_xstring DB 01H
__230C1D2E_castingSafu@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?_Fnv1a_append_bytes@std@@YAIIQBEI@Z		; std::_Fnv1a_append_bytes
PUBLIC	??R?$hash@M@std@@QBEIM@Z			; std::hash<float>::operator()
PUBLIC	??$_Hash_representation@M@std@@YAIABM@Z		; std::_Hash_representation<float>
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked
PUBLIC	?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
PUBLIC	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
PUBLIC	?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
PUBLIC	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
PUBLIC	?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
PUBLIC	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?min@_Rand_urng_from_func@std@@SAIXZ		; std::_Rand_urng_from_func::min
PUBLIC	?max@_Rand_urng_from_func@std@@SAIXZ		; std::_Rand_urng_from_func::max
PUBLIC	??R_Rand_urng_from_func@std@@QAEIXZ		; std::_Rand_urng_from_func::operator()
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Convert_size@II@std@@YAII@Z			; std::_Convert_size<unsigned int,unsigned int>
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$_Fnv1a_append_value@M@std@@YAIIABM@Z		; std::_Fnv1a_append_value<float>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?PrintName@Entity@@UAEXXZ			; Entity::PrintName
PUBLIC	?PrintPosition@Entity@@UAEXXZ			; Entity::PrintPosition
PUBLIC	??1Entity@@UAE@XZ				; Entity::~Entity
PUBLIC	?hash_value@@YAIABVEntity@@@Z			; hash_value
PUBLIC	??0Entity@@QAE@XZ				; Entity::Entity
PUBLIC	??0Entity@@QAE@ABV0@@Z				; Entity::Entity
PUBLIC	??_GEntity@@UAEPAXI@Z				; Entity::`scalar deleting destructor'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$hash_combine@MM@@YAIABM0@Z			; hash_combine<float,float>
PUBLIC	?PrintName@Player@@UAEXXZ			; Player::PrintName
PUBLIC	?PrintGold@Player@@QAEXXZ			; Player::PrintGold
PUBLIC	?PrintPlayerName@Player@@QAEXXZ			; Player::PrintPlayerName
PUBLIC	??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Player::Player
PUBLIC	??0Player@@QAE@ABV0@@Z				; Player::Player
PUBLIC	??1Player@@UAE@XZ				; Player::~Player
PUBLIC	??_GPlayer@@UAEPAXI@Z				; Player::`scalar deleting destructor'
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?PrintName@Enemy@@UAEXXZ			; Enemy::PrintName
PUBLIC	?PrintHealth@Enemy@@QAEXXZ			; Enemy::PrintHealth
PUBLIC	?PrintEnemyName@Enemy@@QAEXXZ			; Enemy::PrintEnemyName
PUBLIC	?PrintGoldDrop@Enemy@@QAEXXZ			; Enemy::PrintGoldDrop
PUBLIC	??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; Enemy::Enemy
PUBLIC	??0Enemy@@QAE@ABV0@@Z				; Enemy::Enemy
PUBLIC	??0Enemy@@QAE@$$QAV0@@Z				; Enemy::Enemy
PUBLIC	??1Enemy@@UAE@XZ				; Enemy::~Enemy
PUBLIC	??_GEnemy@@UAEPAXI@Z				; Enemy::`scalar deleting destructor'
PUBLIC	_main
PUBLIC	??0?$allocator@VPlayer@@@std@@QAE@XZ		; std::allocator<Player>::allocator<Player>
PUBLIC	?deallocate@?$allocator@VPlayer@@@std@@QAEXQAVPlayer@@I@Z ; std::allocator<Player>::deallocate
PUBLIC	?allocate@?$allocator@VPlayer@@@std@@QAEPAVPlayer@@I@Z ; std::allocator<Player>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAIABV?$allocator@VPlayer@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Player> >::max_size
PUBLIC	??0?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@V?$initializer_list@VPlayer@@@1@ABV?$allocator@VPlayer@@@1@@Z ; std::vector<Player,std::allocator<Player> >::vector<Player,std::allocator<Player> >
PUBLIC	??1?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ; std::vector<Player,std::allocator<Player> >::~vector<Player,std::allocator<Player> >
PUBLIC	?_Unchecked_begin@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ; std::vector<Player,std::allocator<Player> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ; std::vector<Player,std::allocator<Player> >::_Unchecked_end
PUBLIC	?max_size@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QBEIXZ ; std::vector<Player,std::allocator<Player> >::max_size
PUBLIC	?_Buy_raw@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z ; std::vector<Player,std::allocator<Player> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z ; std::vector<Player,std::allocator<Player> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ ; std::vector<Player,std::allocator<Player> >::_Tidy
PUBLIC	?_Xlength@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@CAXXZ ; std::vector<Player,std::allocator<Player> >::_Xlength
PUBLIC	?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ ; std::vector<Player,std::allocator<Player> >::_Getal
PUBLIC	?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@ABEABV?$allocator@VPlayer@@@2@XZ ; std::vector<Player,std::allocator<Player> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Player> >::_Vector_val<std::_Simple_types<Player> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAEAAV?$allocator@VPlayer@@@2@XZ ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QBEABV?$allocator@VPlayer@@@2@XZ ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z ; std::vector<Player,std::allocator<Player> >::__autoclassinit2
PUBLIC	??0?$initializer_list@VPlayer@@@std@@QAE@PBVPlayer@@0@Z ; std::initializer_list<Player>::initializer_list<Player>
PUBLIC	?begin@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ ; std::initializer_list<Player>::begin
PUBLIC	?end@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ ; std::initializer_list<Player>::end
PUBLIC	?size@?$initializer_list@VPlayer@@@std@@QBEIXZ	; std::initializer_list<Player>::size
PUBLIC	??0?$allocator@VEnemy@@@std@@QAE@XZ		; std::allocator<Enemy>::allocator<Enemy>
PUBLIC	?deallocate@?$allocator@VEnemy@@@std@@QAEXQAVEnemy@@I@Z ; std::allocator<Enemy>::deallocate
PUBLIC	?allocate@?$allocator@VEnemy@@@std@@QAEPAVEnemy@@I@Z ; std::allocator<Enemy>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAIABV?$allocator@VEnemy@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Enemy> >::max_size
PUBLIC	??0?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@V?$initializer_list@VEnemy@@@1@ABV?$allocator@VEnemy@@@1@@Z ; std::vector<Enemy,std::allocator<Enemy> >::vector<Enemy,std::allocator<Enemy> >
PUBLIC	??1?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy,std::allocator<Enemy> >::~vector<Enemy,std::allocator<Enemy> >
PUBLIC	?_Unchecked_begin@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_end
PUBLIC	?max_size@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy,std::allocator<Enemy> >::max_size
PUBLIC	?_Buy_raw@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ ; std::vector<Enemy,std::allocator<Enemy> >::_Tidy
PUBLIC	?_Xlength@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@CAXXZ ; std::vector<Enemy,std::allocator<Enemy> >::_Xlength
PUBLIC	?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
PUBLIC	?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@ABEABV?$allocator@VEnemy@@@2@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Enemy> >::_Vector_val<std::_Simple_types<Enemy> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAEAAV?$allocator@VEnemy@@@2@XZ ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QBEABV?$allocator@VEnemy@@@2@XZ ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z ; std::vector<Enemy,std::allocator<Enemy> >::__autoclassinit2
PUBLIC	??0?$initializer_list@VEnemy@@@std@@QAE@PBVEnemy@@0@Z ; std::initializer_list<Enemy>::initializer_list<Enemy>
PUBLIC	?begin@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ ; std::initializer_list<Enemy>::begin
PUBLIC	?end@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ ; std::initializer_list<Enemy>::end
PUBLIC	?size@?$initializer_list@VEnemy@@@std@@QBEIXZ	; std::initializer_list<Enemy>::size
PUBLIC	??0?$allocator@PAVEntity@@@std@@QAE@XZ		; std::allocator<Entity *>::allocator<Entity *>
PUBLIC	?deallocate@?$allocator@PAVEntity@@@std@@QAEXQAPAVEntity@@I@Z ; std::allocator<Entity *>::deallocate
PUBLIC	?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z ; std::allocator<Entity *>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Entity *> >::max_size
PUBLIC	??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
PUBLIC	??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
PUBLIC	?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::push_back
PUBLIC	?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::begin
PUBLIC	?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::end
PUBLIC	?_Unchecked_begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_end
PUBLIC	?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::max_size
PUBLIC	?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::capacity
PUBLIC	?_Calculate_growth@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEII@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXQAPAVEntity@@II@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@CAXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
PUBLIC	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEABV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVEntity@@@2@XZ ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$allocator@PAVEntity@@@2@XZ ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z ; std::vector<Entity *,std::allocator<Entity *> >::__autoclassinit2
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0@Z ; std::_Verify_range
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unwrapped
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z ; std::random_shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<Entity *> > >
PUBLIC	??$_Emplace_one_at_back@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_one_at_back<Entity *>
PUBLIC	??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1><>
PUBLIC	??$?0VEnemy@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VEnemy@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Enemy>
PUBLIC	??$?0ABV?$allocator@VEnemy@@@std@@$$V@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VEnemy@@@1@@Z ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1><std::allocator<Enemy> const &>
PUBLIC	??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z ; std::vector<Enemy,std::allocator<Enemy> >::_Construct_n<Enemy const *,Enemy const *>
PUBLIC	??$?0VPlayer@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VPlayer@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Player>
PUBLIC	??$?0ABV?$allocator@VPlayer@@@std@@$$V@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VPlayer@@@1@@Z ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1><std::allocator<Player> const &>
PUBLIC	??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z ; std::vector<Player,std::allocator<Player> >::_Construct_n<Player const *,Player const *>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Destroy_range<std::allocator<Entity *> >
PUBLIC	??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z ; std::_Destroy_range<std::allocator<Enemy> >
PUBLIC	??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z ; std::_Destroy_range<std::allocator<Player> >
PUBLIC	??$hash_combine_impl@MM@@YAXAAIABM1@Z		; hash_combine_impl<float,float>
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z ; std::shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rand_urng_from_func &>
PUBLIC	??$_Emplace_back_with_unused_capacity@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_back_with_unused_capacity<Entity *>
PUBLIC	??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_reallocate<Entity *>
PUBLIC	??1?$_Tidy_guard@V?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >::~_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >
PUBLIC	??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z ; std::_Uninitialized_copy<Enemy const *,Enemy const *,std::allocator<Enemy> >
PUBLIC	??1?$_Tidy_guard@V?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<Player,std::allocator<Player> > >::~_Tidy_guard<std::vector<Player,std::allocator<Player> > >
PUBLIC	??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z ; std::_Uninitialized_copy<Player const *,Player const *,std::allocator<Player> >
PUBLIC	??$_Unfancy@VEnemy@@@std@@YAPAVEnemy@@PAV1@@Z	; std::_Unfancy<Enemy>
PUBLIC	??$destroy@VEnemy@@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@@Z ; std::_Default_allocator_traits<std::allocator<Enemy> >::destroy<Enemy>
PUBLIC	??$_Unfancy@VPlayer@@@std@@YAPAVPlayer@@PAV1@@Z	; std::_Unfancy<Player>
PUBLIC	??$destroy@VPlayer@@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@@Z ; std::_Default_allocator_traits<std::allocator<Player> >::destroy<Player>
PUBLIC	??$_Get_size_of_n@$0DA@@std@@YAII@Z		; std::_Get_size_of_n<48>
PUBLIC	??$_Get_size_of_n@$0CM@@std@@YAII@Z		; std::_Get_size_of_n<44>
PUBLIC	??$hash_combine_impl@M@@YAXAAIABM@Z		; hash_combine_impl<float>
PUBLIC	??0?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAE@AAU_Rand_urng_from_func@1@@Z ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Rng_from_urng<int,std::_Rand_urng_from_func>
PUBLIC	??R?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAEHH@Z ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::operator()
PUBLIC	?_Get_bits@?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@AAEIXZ ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Get_bits
PUBLIC	??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rng_from_urng<int,std::_Rand_urng_from_func> >
PUBLIC	??$_Construct_in_place@PAVEntity@@PAV1@@std@@YAXAAPAVEntity@@$$QAPAV1@@Z ; std::_Construct_in_place<Entity *,Entity *>
PUBLIC	??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unfancy<Entity *>
PUBLIC	??$construct@PAVEntity@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@QAPAVEntity@@$$QAPAV3@@Z ; std::_Default_allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity *>
PUBLIC	??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Uninitialized_move<Entity * *,std::allocator<Entity *> >
PUBLIC	??$_Get_unwrapped@PBVEnemy@@@std@@YA?A_T$$QAPBVEnemy@@@Z ; std::_Get_unwrapped<Enemy const *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@PAVEnemy@@AAV?$allocator@VEnemy@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Uninitialized_backout_al<std::allocator<Enemy> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::~_Uninitialized_backout_al<std::allocator<Enemy> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABVEnemy@@@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXABVEnemy@@@Z ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Emplace_back<Enemy const &>
PUBLIC	??$_Get_unwrapped@PBVPlayer@@@std@@YA?A_T$$QAPBVPlayer@@@Z ; std::_Get_unwrapped<Player const *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@PAVPlayer@@AAV?$allocator@VPlayer@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Uninitialized_backout_al<std::allocator<Player> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Player> >::~_Uninitialized_backout_al<std::allocator<Player> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<Player> >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABVPlayer@@@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXABVPlayer@@@Z ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Emplace_back<Player const &>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
PUBLIC	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > &>
PUBLIC	??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z ; std::iter_swap<Entity * *,Entity * *>
PUBLIC	??$addressof@PAVEntity@@@std@@YAPAPAVEntity@@AAPAV1@@Z ; std::addressof<Entity *>
PUBLIC	??$_Voidify_iter@PAPAVEntity@@@std@@YAPAXPAPAVEntity@@@Z ; std::_Voidify_iter<Entity * *>
PUBLIC	??$_Get_unwrapped@ABQAPAVEntity@@@std@@YA?A_TABQAPAVEntity@@@Z ; std::_Get_unwrapped<Entity * * const &>
PUBLIC	??$_Copy_memmove@PAPAVEntity@@PAPAV1@@std@@YAPAPAVEntity@@PAPAV1@00@Z ; std::_Copy_memmove<Entity * *,Entity * *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@PAPAVEntity@@AAV?$allocator@PAVEntity@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Uninitialized_backout_al<std::allocator<Entity *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::~_Uninitialized_backout_al<std::allocator<Entity *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::__autoclassinit2
PUBLIC	??$_Emplace_back@PAVEntity@@@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Emplace_back<Entity *>
PUBLIC	??$construct@VEnemy@@ABV1@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@ABV3@@Z ; std::_Default_allocator_traits<std::allocator<Enemy> >::construct<Enemy,Enemy const &>
PUBLIC	??$construct@VPlayer@@ABV1@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@ABV3@@Z ; std::_Default_allocator_traits<std::allocator<Player> >::construct<Player,Player const &>
PUBLIC	??$swap@PAVEntity@@$0A@@std@@YAXAAPAVEntity@@0@Z ; std::swap<Entity *,0>
PUBLIC	??$_To_address@PAPAVEntity@@@std@@YA?A_PABQAPAVEntity@@@Z ; std::_To_address<Entity * *>
PUBLIC	??$_Voidify_iter@PAVEnemy@@@std@@YAPAXPAVEnemy@@@Z ; std::_Voidify_iter<Enemy *>
PUBLIC	??$_Voidify_iter@PAVPlayer@@@std@@YAPAXPAVPlayer@@@Z ; std::_Voidify_iter<Player *>
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7Entity@@6B@					; Entity::`vftable'
PUBLIC	??_C@_06KBCHOIMA@Entity@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5@				; `string'
PUBLIC	??_7Player@@6B@					; Player::`vftable'
PUBLIC	??_C@_06NPAAKFED@Player@			; `string'
PUBLIC	??_7Enemy@@6B@					; Enemy::`vftable'
PUBLIC	??_C@_05IFKAJBFC@Enemy@				; `string'
PUBLIC	??_C@_0BC@IJCJGND@Enemy?5constructor@		; `string'
PUBLIC	??_C@_0BH@IGCNJKLE@Enemy?5copy?5constructor@	; `string'
PUBLIC	??_C@_0BA@KEIMIMCK@?5and?5gold?5drop?5@		; `string'
PUBLIC	??_C@_0O@ONJBCCPN@?5with?5health?5@		; `string'
PUBLIC	??_C@_0BD@BFAEABIL@copy?5constructing?5@	; `string'
PUBLIC	??_C@_0BH@KJLEBLJB@Enemy?5move?5constructor@	; `string'
PUBLIC	??_C@_0BD@GHEIENED@move?5constructing?5@	; `string'
PUBLIC	??_R0?AVEntity@@@8				; Entity `RTTI Type Descriptor'
PUBLIC	??_R0?AVPlayer@@@8				; Player `RTTI Type Descriptor'
PUBLIC	??_R0?AVEnemy@@@8				; Enemy `RTTI Type Descriptor'
PUBLIC	??_C@_04FKFAIKFI@e?3?5?5@			; `string'
PUBLIC	??_C@_04IOFFIEBB@e2?3?5@			; `string'
PUBLIC	??_C@_04DGOJODHE@e3?3?5@			; `string'
PUBLIC	??_C@_04KLDONLMN@e4?3?5@			; `string'
PUBLIC	??_C@_04BDICLMKI@e5?3?5@			; `string'
PUBLIC	??_C@_08GBBKBKMM@enemy?3?5?5@			; `string'
PUBLIC	??_C@_08LFBPBEIF@enemy2?3?5@			; `string'
PUBLIC	??_C@_08NKDHDOA@enemy3?3?5@			; `string'
PUBLIC	??_C@_08JAHEELFJ@enemy4?3?5@			; `string'
PUBLIC	??_C@_08CIMICMDM@enemy5?3?5@			; `string'
PUBLIC	??_C@_0BB@OGJJDCHI@Size?5of?5player?3?5@	; `string'
PUBLIC	??_C@_07CHKEEPO@Player2@			; `string'
PUBLIC	??_C@_0BC@BPLJEKNH@Size?5of?5player2?3?5@	; `string'
PUBLIC	??_C@_07CJFHBHDN@Player1@			; `string'
PUBLIC	??_C@_07BLGBHFLP@Player3@			; `string'
PUBLIC	??_C@_07FECAODHI@Player4@			; `string'
PUBLIC	??_C@_06EDLNJHPL@Enemy1@			; `string'
PUBLIC	??_C@_06GIJAMEDI@Enemy2@			; `string'
PUBLIC	??_C@_06HBILPFHJ@Enemy3@			; `string'
PUBLIC	??_C@_06DOMKGDLO@Enemy4@			; `string'
PUBLIC	??_C@_0M@KCDFEKHC@?5with?5gold?5@		; `string'
PUBLIC	??_C@_0N@LFABCOLI@hash?5of?5e?3?5?5@		; `string'
PUBLIC	??_C@_0N@GBAECAPB@hash?5of?5e2?3?5@		; `string'
PUBLIC	??_C@_0N@NJLIEHJE@hash?5of?5e3?3?5@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0BK@EIGCDBID@random?5value?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0GE@GNIOLONC@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MI@NOGIBNK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DI@PGFAEKLK@?$AA?$CC?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AA?5?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AAo@ ; `string'
PUBLIC	??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@ ; `string'
PUBLIC	??_C@_0GB@NEMOGBCE@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1MC@BDGGHEJF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@ ; `string'
PUBLIC	??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_R4Entity@@6B@				; Entity::`RTTI Complete Object Locator'
PUBLIC	??_R3Entity@@8					; Entity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Entity@@8					; Entity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Entity@@8				; Entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Player@@6B@				; Player::`RTTI Complete Object Locator'
PUBLIC	??_R3Player@@8					; Player::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Player@@8					; Player::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Player@@8				; Player::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Enemy@@6B@					; Enemy::`RTTI Complete Object Locator'
PUBLIC	??_R3Enemy@@8					; Enemy::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Enemy@@8					; Enemy::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Enemy@@8				; Enemy::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp__rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	??_EEntity@@UAEPAXI@Z:PROC			; Entity::`vector deleting destructor'
EXTRN	??_EPlayer@@UAEPAXI@Z:PROC			; Player::`vector deleting destructor'
EXTRN	??_EEnemy@@UAEPAXI@Z:PROC			; Enemy::`vector deleting destructor'
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___RTDynamicCast:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@Enemy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Enemy@@8 DD FLAT:??_R0?AVEnemy@@@8	; Enemy::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Enemy@@8
rdata$r	ENDS
;	COMDAT ??_R2Enemy@@8
rdata$r	SEGMENT
??_R2Enemy@@8 DD FLAT:??_R1A@?0A@EA@Enemy@@8		; Enemy::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Entity@@8
rdata$r	ENDS
;	COMDAT ??_R3Enemy@@8
rdata$r	SEGMENT
??_R3Enemy@@8 DD 00H					; Enemy::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Enemy@@8
rdata$r	ENDS
;	COMDAT ??_R4Enemy@@6B@
rdata$r	SEGMENT
??_R4Enemy@@6B@ DD 00H					; Enemy::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEnemy@@@8
	DD	FLAT:??_R3Enemy@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Player@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Player@@8 DD FLAT:??_R0?AVPlayer@@@8	; Player::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Player@@8
rdata$r	ENDS
;	COMDAT ??_R2Player@@8
rdata$r	SEGMENT
??_R2Player@@8 DD FLAT:??_R1A@?0A@EA@Player@@8		; Player::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Entity@@8
rdata$r	ENDS
;	COMDAT ??_R3Player@@8
rdata$r	SEGMENT
??_R3Player@@8 DD 00H					; Player::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Player@@8
rdata$r	ENDS
;	COMDAT ??_R4Player@@6B@
rdata$r	SEGMENT
??_R4Player@@6B@ DD 00H					; Player::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPlayer@@@8
	DD	FLAT:??_R3Player@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Entity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Entity@@8 DD FLAT:??_R0?AVEntity@@@8	; Entity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Entity@@8
rdata$r	ENDS
;	COMDAT ??_R2Entity@@8
rdata$r	SEGMENT
??_R2Entity@@8 DD FLAT:??_R1A@?0A@EA@Entity@@8		; Entity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Entity@@8
rdata$r	SEGMENT
??_R3Entity@@8 DD 00H					; Entity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Entity@@8
rdata$r	ENDS
;	COMDAT ??_R4Entity@@6B@
rdata$r	SEGMENT
??_R4Entity@@6B@ DD 00H					; Entity::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVEntity@@@8
	DD	FLAT:??_R3Entity@@8
rdata$r	ENDS
;	COMDAT ??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'n'
	DB	00H, 's', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'e', 00H, 'd', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@
CONST	SEGMENT
??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@ DB 'vector iterato'
	DB	'r range transposed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, ' '
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'r', 00H
	DB	'o', 00H, 'm', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MC@BDGGHEJF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MC@BDGGHEJF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '5', 00H, '.', 00H, '3', 00H, '2', 00H, '2'
	DB	00H, '1', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@NEMOGBCE@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GB@NEMOGBCE@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'35.32215\include\vector', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@
CONST	SEGMENT
??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@ DB 'vector itera'
	DB	'tors in range are from different containers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@PGFAEKLK@?$AA?$CC?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AA?5?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AAo@
CONST	SEGMENT
??_C@_1DI@PGFAEKLK@?$AA?$CC?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AA?5?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AAo@ DB '"'
	DB	00H, 'r', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'm', 00H
	DB	' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' '
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MI@NOGIBNK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MI@NOGIBNK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '5', 00H, '.', 00H, '3', 00H, '2', 00H, '2'
	DB	00H, '1', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'm', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@GNIOLONC@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GE@GNIOLONC@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'35.32215\include\algorithm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EIGCDBID@random?5value?5out?5of?5range@
CONST	SEGMENT
??_C@_0BK@EIGCDBID@random?5value?5out?5of?5range@ DB 'random value out of'
	DB	' range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NJLIEHJE@hash?5of?5e3?3?5@
CONST	SEGMENT
??_C@_0N@NJLIEHJE@hash?5of?5e3?3?5@ DB 'hash of e3: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GBAECAPB@hash?5of?5e2?3?5@
CONST	SEGMENT
??_C@_0N@GBAECAPB@hash?5of?5e2?3?5@ DB 'hash of e2: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LFABCOLI@hash?5of?5e?3?5?5@
CONST	SEGMENT
??_C@_0N@LFABCOLI@hash?5of?5e?3?5?5@ DB 'hash of e:  ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KCDFEKHC@?5with?5gold?5@
CONST	SEGMENT
??_C@_0M@KCDFEKHC@?5with?5gold?5@ DB ' with gold ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOMKGDLO@Enemy4@
CONST	SEGMENT
??_C@_06DOMKGDLO@Enemy4@ DB 'Enemy4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBILPFHJ@Enemy3@
CONST	SEGMENT
??_C@_06HBILPFHJ@Enemy3@ DB 'Enemy3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GIJAMEDI@Enemy2@
CONST	SEGMENT
??_C@_06GIJAMEDI@Enemy2@ DB 'Enemy2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EDLNJHPL@Enemy1@
CONST	SEGMENT
??_C@_06EDLNJHPL@Enemy1@ DB 'Enemy1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FECAODHI@Player4@
CONST	SEGMENT
??_C@_07FECAODHI@Player4@ DB 'Player4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BLGBHFLP@Player3@
CONST	SEGMENT
??_C@_07BLGBHFLP@Player3@ DB 'Player3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CJFHBHDN@Player1@
CONST	SEGMENT
??_C@_07CJFHBHDN@Player1@ DB 'Player1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BPLJEKNH@Size?5of?5player2?3?5@
CONST	SEGMENT
??_C@_0BC@BPLJEKNH@Size?5of?5player2?3?5@ DB 'Size of player2: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHKEEPO@Player2@
CONST	SEGMENT
??_C@_07CHKEEPO@Player2@ DB 'Player2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OGJJDCHI@Size?5of?5player?3?5@
CONST	SEGMENT
??_C@_0BB@OGJJDCHI@Size?5of?5player?3?5@ DB 'Size of player: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIMICMDM@enemy5?3?5@
CONST	SEGMENT
??_C@_08CIMICMDM@enemy5?3?5@ DB 'enemy5: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAHEELFJ@enemy4?3?5@
CONST	SEGMENT
??_C@_08JAHEELFJ@enemy4?3?5@ DB 'enemy4: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NKDHDOA@enemy3?3?5@
CONST	SEGMENT
??_C@_08NKDHDOA@enemy3?3?5@ DB 'enemy3: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LFBPBEIF@enemy2?3?5@
CONST	SEGMENT
??_C@_08LFBPBEIF@enemy2?3?5@ DB 'enemy2: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBBKBKMM@enemy?3?5?5@
CONST	SEGMENT
??_C@_08GBBKBKMM@enemy?3?5?5@ DB 'enemy:  ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BDICLMKI@e5?3?5@
CONST	SEGMENT
??_C@_04BDICLMKI@e5?3?5@ DB 'e5: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLDONLMN@e4?3?5@
CONST	SEGMENT
??_C@_04KLDONLMN@e4?3?5@ DB 'e4: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGOJODHE@e3?3?5@
CONST	SEGMENT
??_C@_04DGOJODHE@e3?3?5@ DB 'e3: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOFFIEBB@e2?3?5@
CONST	SEGMENT
??_C@_04IOFFIEBB@e2?3?5@ DB 'e2: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FKFAIKFI@e?3?5?5@
CONST	SEGMENT
??_C@_04FKFAIKFI@e?3?5?5@ DB 'e:  ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_R0?AVEnemy@@@8
data$r	SEGMENT
??_R0?AVEnemy@@@8 DD FLAT:??_7type_info@@6B@		; Enemy `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEnemy@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVPlayer@@@8
data$r	SEGMENT
??_R0?AVPlayer@@@8 DD FLAT:??_7type_info@@6B@		; Player `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPlayer@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVEntity@@@8
data$r	SEGMENT
??_R0?AVEntity@@@8 DD FLAT:??_7type_info@@6B@		; Entity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVEntity@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BD@GHEIENED@move?5constructing?5@
CONST	SEGMENT
??_C@_0BD@GHEIENED@move?5constructing?5@ DB 'move constructing ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KJLEBLJB@Enemy?5move?5constructor@
CONST	SEGMENT
??_C@_0BH@KJLEBLJB@Enemy?5move?5constructor@ DB 'Enemy move constructor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BFAEABIL@copy?5constructing?5@
CONST	SEGMENT
??_C@_0BD@BFAEABIL@copy?5constructing?5@ DB 'copy constructing ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ONJBCCPN@?5with?5health?5@
CONST	SEGMENT
??_C@_0O@ONJBCCPN@?5with?5health?5@ DB ' with health ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KEIMIMCK@?5and?5gold?5drop?5@
CONST	SEGMENT
??_C@_0BA@KEIMIMCK@?5and?5gold?5drop?5@ DB ' and gold drop ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IGCNJKLE@Enemy?5copy?5constructor@
CONST	SEGMENT
??_C@_0BH@IGCNJKLE@Enemy?5copy?5constructor@ DB 'Enemy copy constructor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IJCJGND@Enemy?5constructor@
CONST	SEGMENT
??_C@_0BC@IJCJGND@Enemy?5constructor@ DB 'Enemy constructor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFKAJBFC@Enemy@
CONST	SEGMENT
??_C@_05IFKAJBFC@Enemy@ DB 'Enemy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7Enemy@@6B@
CONST	SEGMENT
??_7Enemy@@6B@ DD FLAT:??_R4Enemy@@6B@			; Enemy::`vftable'
	DD	FLAT:?PrintName@Enemy@@UAEXXZ
	DD	FLAT:?PrintPosition@Entity@@UAEXXZ
	DD	FLAT:??_EEnemy@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_06NPAAKFED@Player@
CONST	SEGMENT
??_C@_06NPAAKFED@Player@ DB 'Player', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7Player@@6B@
CONST	SEGMENT
??_7Player@@6B@ DD FLAT:??_R4Player@@6B@		; Player::`vftable'
	DD	FLAT:?PrintName@Player@@UAEXXZ
	DD	FLAT:?PrintPosition@Entity@@UAEXXZ
	DD	FLAT:??_EPlayer@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KBCHOIMA@Entity@
CONST	SEGMENT
??_C@_06KBCHOIMA@Entity@ DB 'Entity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7Entity@@6B@
CONST	SEGMENT
??_7Entity@@6B@ DD FLAT:??_R4Entity@@6B@		; Entity::`vftable'
	DD	FLAT:?PrintName@Entity@@UAEXXZ
	DD	FLAT:?PrintPosition@Entity@@UAEXXZ
	DD	FLAT:??_EEntity@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '5', 00H, '.', 00H, '3', 00H, '2', 00H, '2'
	DB	00H, '1', 00H, '5', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'35.32215\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 091H ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	030H
	DW	0117H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z$1
__ehfuncinfo$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	07bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	030H
	DB	0edH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	030H
	DB	0edH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	02bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	030H
	DB	0c8H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z$1
__ehfuncinfo$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	040fH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	02bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0110H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z$1
__ehfuncinfo$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	02bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0110H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z$1
__ehfuncinfo$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	02bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	030H
	DB	0bcH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z$1
__ehfuncinfo$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	02dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	032H
	DB	0afH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	091H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	091H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	091H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	0167H
	DW	0174H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0d87H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	02dH
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$3
	DD	04H
	DD	FLAT:__unwindfunclet$_main$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$5
	DD	06H
	DD	FLAT:__unwindfunclet$_main$6
	DD	07H
	DD	FLAT:__unwindfunclet$_main$7
	DD	06H
	DD	FLAT:__unwindfunclet$_main$7
	DD	09H
	DD	FLAT:__unwindfunclet$_main$8
	DD	0aH
	DD	FLAT:__unwindfunclet$_main$9
	DD	0bH
	DD	FLAT:__unwindfunclet$_main$10
	DD	0cH
	DD	FLAT:__unwindfunclet$_main$11
	DD	0dH
	DD	FLAT:__unwindfunclet$_main$12
	DD	0eH
	DD	FLAT:__unwindfunclet$_main$13
	DD	0fH
	DD	FLAT:__unwindfunclet$_main$14
	DD	0aH
	DD	FLAT:__unwindfunclet$_main$10
	DD	011H
	DD	FLAT:__unwindfunclet$_main$12
	DD	012H
	DD	FLAT:__unwindfunclet$_main$14
	DD	013H
	DD	FLAT:__unwindfunclet$_main$16
	DD	014H
	DD	FLAT:__unwindfunclet$_main$17
	DD	013H
	DD	FLAT:__unwindfunclet$_main$17
	DD	012H
	DD	FLAT:__unwindfunclet$_main$17
	DD	011H
	DD	FLAT:__unwindfunclet$_main$17
	DD	0aH
	DD	FLAT:__unwindfunclet$_main$17
	DD	09H
	DD	FLAT:__unwindfunclet$_main$17
	DD	01aH
	DD	FLAT:__unwindfunclet$_main$18
	DD	01bH
	DD	FLAT:__unwindfunclet$_main$19
	DD	01cH
	DD	FLAT:__unwindfunclet$_main$20
	DD	01dH
	DD	FLAT:__unwindfunclet$_main$21
	DD	01eH
	DD	FLAT:__unwindfunclet$_main$22
	DD	01fH
	DD	FLAT:__unwindfunclet$_main$23
	DD	020H
	DD	FLAT:__unwindfunclet$_main$24
	DD	01bH
	DD	FLAT:__unwindfunclet$_main$20
	DD	022H
	DD	FLAT:__unwindfunclet$_main$22
	DD	023H
	DD	FLAT:__unwindfunclet$_main$24
	DD	024H
	DD	FLAT:__unwindfunclet$_main$26
	DD	025H
	DD	FLAT:__unwindfunclet$_main$27
	DD	024H
	DD	FLAT:__unwindfunclet$_main$27
	DD	023H
	DD	FLAT:__unwindfunclet$_main$27
	DD	022H
	DD	FLAT:__unwindfunclet$_main$27
	DD	01bH
	DD	FLAT:__unwindfunclet$_main$27
	DD	01aH
	DD	FLAT:__unwindfunclet$_main$27
	DD	02bH
	DD	FLAT:__unwindfunclet$_main$28
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Enemy@@QAE@$$QAV0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Enemy@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Enemy@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Enemy@@QAE@ABV0@@Z$1
__ehfuncinfo$??0Enemy@@QAE@ABV0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Enemy@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$1
__ehfuncinfo$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Player@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@ABV0@@Z$0
__ehfuncinfo$??0Player@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Player@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$0
__ehfuncinfo$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	061H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	0477H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0188H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0
__ehfuncinfo$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	01d1H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0
__ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	090H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	0adH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	090H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	076H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	07aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	07aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	07aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	076H
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Voidify_iter@PAVPlayer@@@std@@YAPAXPAVPlayer@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAVPlayer@@@std@@YAPAXPAVPlayer@@@Z PROC ; std::_Voidify_iter<Player *>, COMDAT

; 244  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 245  :     if constexpr (is_pointer_v<_Iter>) {
; 246  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, DWORD PTR __It$[ebp]

; 247  :     } else {
; 248  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 249  :     }
; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Voidify_iter@PAVPlayer@@@std@@YAPAXPAVPlayer@@@Z ENDP ; std::_Voidify_iter<Player *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Voidify_iter@PAVEnemy@@@std@@YAPAXPAVEnemy@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAVEnemy@@@std@@YAPAXPAVEnemy@@@Z PROC	; std::_Voidify_iter<Enemy *>, COMDAT

; 244  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 245  :     if constexpr (is_pointer_v<_Iter>) {
; 246  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, DWORD PTR __It$[ebp]

; 247  :     } else {
; 248  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 249  :     }
; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Voidify_iter@PAVEnemy@@@std@@YAPAXPAVEnemy@@@Z ENDP	; std::_Voidify_iter<Enemy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_To_address@PAPAVEntity@@@std@@YA?A_PABQAPAVEntity@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAPAVEntity@@@std@@YA?A_PABQAPAVEntity@@@Z PROC ; std::_To_address<Entity * *>, COMDAT

; 4109 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 4110 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4111 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]

; 4112 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_To_address@PAPAVEntity@@@std@@YA?A_PABQAPAVEntity@@@Z ENDP ; std::_To_address<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\utility
;	COMDAT ??$swap@PAVEntity@@$0A@@std@@YAXAAPAVEntity@@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVEntity@@$0A@@std@@YAXAAPAVEntity@@0@Z PROC	; std::swap<Entity *,0>, COMDAT

; 99   :     is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9596B502_utility
	call	@__CheckForDebuggerJustMyCode@4

; 100  :     _Ty _Tmp = _STD move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 101  :     _Left    = _STD move(_Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 102  :     _Right   = _STD move(_Tmp);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@PAVEntity@@$0A@@std@@YAXAAPAVEntity@@0@Z ENDP	; std::swap<Entity *,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$construct@VPlayer@@ABV1@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@ABV3@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@VPlayer@@ABV1@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@ABV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<Player> >::construct<Player,Player const &>, COMDAT

; 673  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 674  : #if _HAS_CXX20
; 675  :         if (_STD is_constant_evaluated()) {
; 676  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 677  :         } else
; 678  : #endif // _HAS_CXX20
; 679  :         {
; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Voidify_iter@PAVPlayer@@@std@@YAPAXPAVPlayer@@@Z ; std::_Voidify_iter<Player *>
	add	esp, 4
	push	eax
	push	44					; 0000002cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0Player@@QAE@ABV0@@Z			; Player::Player

; 681  :         }
; 682  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@VPlayer@@ABV1@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@ABV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Player> >::construct<Player,Player const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$construct@VEnemy@@ABV1@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@ABV3@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@VEnemy@@ABV1@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@ABV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<Enemy> >::construct<Enemy,Enemy const &>, COMDAT

; 673  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 674  : #if _HAS_CXX20
; 675  :         if (_STD is_constant_evaluated()) {
; 676  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 677  :         } else
; 678  : #endif // _HAS_CXX20
; 679  :         {
; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Voidify_iter@PAVEnemy@@@std@@YAPAXPAVEnemy@@@Z ; std::_Voidify_iter<Enemy *>
	add	esp, 4
	push	eax
	push	48					; 00000030H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0Enemy@@QAE@ABV0@@Z			; Enemy::Enemy

; 681  :         }
; 682  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@VEnemy@@ABV1@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@ABV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Enemy> >::construct<Enemy,Enemy const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Emplace_back@PAVEntity@@@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVEntity@@@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Emplace_back<Entity *>, COMDAT
; _this$ = ecx

; 1659 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1660 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unfancy<Entity *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$construct@PAVEntity@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@QAPAVEntity@@$$QAPAV3@@Z ; std::_Default_allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity *>
	add	esp, 12					; 0000000cH

; 1661 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1662 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@PAVEntity@@@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Emplace_back<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Release, COMDAT
; _this$ = ecx

; 1664 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1665 :         _First = _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1666 :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1667 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::~_Uninitialized_backout_al<std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 1654 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1655 :         _Destroy_range(_First, _Last, _Al);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Destroy_range<std::allocator<Entity *> >
	add	esp, 12					; 0000000cH

; 1656 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::~_Uninitialized_backout_al<std::allocator<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@PAPAVEntity@@AAV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@PAPAVEntity@@AAV?$allocator@PAVEntity@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Uninitialized_backout_al<std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 1649 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@PAPAVEntity@@AAV?$allocator@PAVEntity@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Uninitialized_backout_al<std::allocator<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVEntity@@PAPAV1@@std@@YAPAPAVEntity@@PAPAV1@00@Z
_TEXT	SEGMENT
__Count$ = -80						; size = 4
__Dest_ch$ = -68					; size = 4
__Last_ch$ = -56					; size = 4
__First_ch$ = -44					; size = 4
__DestPtr$ = -32					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVEntity@@PAPAV1@@std@@YAPAPAVEntity@@PAPAV1@00@Z PROC ; std::_Copy_memmove<Entity * *,Entity * *>, COMDAT

; 4231 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 4232 :     auto _FirstPtr              = _To_address(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_To_address@PAPAVEntity@@@std@@YA?A_PABQAPAVEntity@@@Z ; std::_To_address<Entity * *>
	add	esp, 4
	mov	DWORD PTR __FirstPtr$[ebp], eax

; 4233 :     auto _LastPtr               = _To_address(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_To_address@PAPAVEntity@@@std@@YA?A_PABQAPAVEntity@@@Z ; std::_To_address<Entity * *>
	add	esp, 4
	mov	DWORD PTR __LastPtr$[ebp], eax

; 4234 :     auto _DestPtr               = _To_address(_Dest);

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_To_address@PAPAVEntity@@@std@@YA?A_PABQAPAVEntity@@@Z ; std::_To_address<Entity * *>
	add	esp, 4
	mov	DWORD PTR __DestPtr$[ebp], eax

; 4235 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

	mov	eax, DWORD PTR __FirstPtr$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 4236 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

	mov	eax, DWORD PTR __LastPtr$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], eax

; 4237 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

	mov	eax, DWORD PTR __DestPtr$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], eax

; 4238 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 4239 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First_ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest_ch$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 4240 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4241 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 4242 :     } else {
; 4243 :         return _Dest + (_LastPtr - _FirstPtr);
; 4244 :     }
; 4245 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAPAVEntity@@PAPAV1@@std@@YAPAPAVEntity@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<Entity * *,Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVEntity@@@std@@YA?A_TABQAPAVEntity@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAPAVEntity@@@std@@YA?A_TABQAPAVEntity@@@Z PROC ; std::_Get_unwrapped<Entity * * const &>, COMDAT

; 956  :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 957  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 958  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 959  :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 960  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 961  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 962  :     } else {
; 963  :         return static_cast<_Iter&&>(_It);
; 964  :     }
; 965  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@ABQAPAVEntity@@@std@@YA?A_TABQAPAVEntity@@@Z ENDP ; std::_Get_unwrapped<Entity * * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAVEntity@@@std@@YAPAXPAPAVEntity@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAPAVEntity@@@std@@YAPAXPAPAVEntity@@@Z PROC ; std::_Voidify_iter<Entity * *>, COMDAT

; 244  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 245  :     if constexpr (is_pointer_v<_Iter>) {
; 246  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, DWORD PTR __It$[ebp]

; 247  :     } else {
; 248  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 249  :     }
; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Voidify_iter@PAPAVEntity@@@std@@YAPAXPAPAVEntity@@@Z ENDP ; std::_Voidify_iter<Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$addressof@PAVEntity@@@std@@YAPAPAVEntity@@AAPAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAVEntity@@@std@@YAPAPAVEntity@@AAPAV1@@Z PROC ; std::addressof<Entity *>, COMDAT

; 280  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 282  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@PAVEntity@@@std@@YAPAPAVEntity@@AAPAV1@@Z ENDP ; std::addressof<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\utility
;	COMDAT ??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z PROC ; std::iter_swap<Entity * *,Entity * *>, COMDAT

; 77   : _CONSTEXPR20 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { // swap *_Left and *_Right

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9596B502_utility
	call	@__CheckForDebuggerJustMyCode@4

; 78   :     swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$swap@PAVEntity@@$0A@@std@@YAXAAPAVEntity@@0@Z ; std::swap<Entity *,0>
	add	esp, 8

; 79   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z ENDP ; std::iter_swap<Entity * *,Entity * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > &>, COMDAT

; 956  :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 957  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 958  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 959  :         return _It + 0;
; 960  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 961  :         return static_cast<_Iter&&>(_It)._Unwrapped();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unwrapped

; 962  :     } else {
; 963  :         return static_cast<_Iter&&>(_It);
; 964  :     }
; 965  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT

; 933  : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 934  :     // check that [_First, _Last) forms an iterator range
; 935  :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 936  :         _Verify_range(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0@Z ; std::_Verify_range
	add	esp, 8

; 937  :     }
; 938  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Emplace_back@ABVPlayer@@@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXABVPlayer@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABVPlayer@@@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXABVPlayer@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Emplace_back<Player const &>, COMDAT
; _this$ = ecx

; 1659 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1660 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Unfancy@VPlayer@@@std@@YAPAVPlayer@@PAV1@@Z ; std::_Unfancy<Player>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$construct@VPlayer@@ABV1@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@ABV3@@Z ; std::_Default_allocator_traits<std::allocator<Player> >::construct<Player,Player const &>
	add	esp, 12					; 0000000cH

; 1661 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1662 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@ABVPlayer@@@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXABVPlayer@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Emplace_back<Player const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Player> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Player> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Release, COMDAT
; _this$ = ecx

; 1664 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1665 :         _First = _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1666 :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1667 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Player> >::~_Uninitialized_backout_al<std::allocator<Player> >, COMDAT
; _this$ = ecx

; 1654 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1655 :         _Destroy_range(_First, _Last, _Al);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z ; std::_Destroy_range<std::allocator<Player> >
	add	esp, 12					; 0000000cH

; 1656 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Player> >::~_Uninitialized_backout_al<std::allocator<Player> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@PAVPlayer@@AAV?$allocator@VPlayer@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@PAVPlayer@@AAV?$allocator@VPlayer@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Uninitialized_backout_al<std::allocator<Player> >, COMDAT
; _this$ = ecx

; 1649 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@PAVPlayer@@AAV?$allocator@VPlayer@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Uninitialized_backout_al<std::allocator<Player> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Get_unwrapped@PBVPlayer@@@std@@YA?A_T$$QAPBVPlayer@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@PBVPlayer@@@std@@YA?A_T$$QAPBVPlayer@@@Z PROC ; std::_Get_unwrapped<Player const *>, COMDAT

; 956  :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 957  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 958  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 959  :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 960  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 961  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 962  :     } else {
; 963  :         return static_cast<_Iter&&>(_It);
; 964  :     }
; 965  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@PBVPlayer@@@std@@YA?A_T$$QAPBVPlayer@@@Z ENDP ; std::_Get_unwrapped<Player const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Emplace_back@ABVEnemy@@@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXABVEnemy@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABVEnemy@@@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXABVEnemy@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Emplace_back<Enemy const &>, COMDAT
; _this$ = ecx

; 1659 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1660 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

	mov	eax, DWORD PTR _<_Vals_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$_Unfancy@VEnemy@@@std@@YAPAVEnemy@@PAV1@@Z ; std::_Unfancy<Enemy>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$construct@VEnemy@@ABV1@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@ABV3@@Z ; std::_Default_allocator_traits<std::allocator<Enemy> >::construct<Enemy,Enemy const &>
	add	esp, 12					; 0000000cH

; 1661 :         ++_Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1662 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back@ABVEnemy@@@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXABVEnemy@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Emplace_back<Enemy const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Release, COMDAT
; _this$ = ecx

; 1664 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1665 :         _First = _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1666 :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1667 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::~_Uninitialized_backout_al<std::allocator<Enemy> >, COMDAT
; _this$ = ecx

; 1654 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1655 :         _Destroy_range(_First, _Last, _Al);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z ; std::_Destroy_range<std::allocator<Enemy> >
	add	esp, 12					; 0000000cH

; 1656 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::~_Uninitialized_backout_al<std::allocator<Enemy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@PAVEnemy@@AAV?$allocator@VEnemy@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@PAVEnemy@@AAV?$allocator@VEnemy@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Uninitialized_backout_al<std::allocator<Enemy> >, COMDAT
; _this$ = ecx

; 1649 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@PAVEnemy@@AAV?$allocator@VEnemy@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Uninitialized_backout_al<std::allocator<Enemy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Get_unwrapped@PBVEnemy@@@std@@YA?A_T$$QAPBVEnemy@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@PBVEnemy@@@std@@YA?A_T$$QAPBVEnemy@@@Z PROC ; std::_Get_unwrapped<Enemy const *>, COMDAT

; 956  :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 957  :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 958  :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 959  :         return _It + 0;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 960  :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 961  :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 962  :     } else {
; 963  :         return static_cast<_Iter&&>(_It);
; 964  :     }
; 965  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_unwrapped@PBVEnemy@@@std@@YA?A_T$$QAPBVEnemy@@@Z ENDP ; std::_Get_unwrapped<Enemy const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z
_TEXT	SEGMENT
$T2 = -260						; size = 4
__Backout$ = -56					; size = 12
__ULast$ = -36						; size = 4
__UFirst$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z PROC ; std::_Uninitialized_move<Entity * *,std::allocator<Entity *> >, COMDAT

; 1785 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1786 :     // move [_First, _Last) to raw _Dest, using _Al
; 1787 :     // note: only called internally from elsewhere in the STL
; 1788 :     using _Ptrval     = typename _Alloc::value_type*;
; 1789 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAPAVEntity@@@std@@YA?A_TABQAPAVEntity@@@Z ; std::_Get_unwrapped<Entity * * const &>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1790 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@ABQAPAVEntity@@@std@@YA?A_TABQAPAVEntity@@@Z ; std::_Get_unwrapped<Entity * * const &>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 1791 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1792 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1793 : #if _HAS_CXX20
; 1794 :         if (!_STD is_constant_evaluated())
; 1795 : #endif // _HAS_CXX20
; 1796 :         {
; 1797 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unfancy<Entity *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __ULast$[ebp]
	push	ecx
	mov	edx, DWORD PTR __UFirst$[ebp]
	push	edx
	call	??$_Copy_memmove@PAPAVEntity@@PAPAV1@@std@@YAPAPAVEntity@@PAPAV1@00@Z ; std::_Copy_memmove<Entity * *,Entity * *>
	add	esp, 12					; 0000000cH

; 1798 :             return _Dest + (_ULast - _UFirst);

	mov	eax, DWORD PTR __ULast$[ebp]
	sub	eax, DWORD PTR __UFirst$[ebp]
	sar	eax, 2
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN1@Uninitiali

; 1799 :         }
; 1800 :     }
; 1801 : 
; 1802 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	push	12					; 0000000cH
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@PAPAVEntity@@AAV?$allocator@PAVEntity@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Uninitialized_backout_al<std::allocator<Entity *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1803 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 4
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@Uninitiali

; 1804 :         _Backout._Emplace_back(_STD move(*_UFirst));

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@PAVEntity@@@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Emplace_back<Entity *>

; 1805 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1806 : 
; 1807 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::~_Uninitialized_backout_al<std::allocator<Entity *> >
	mov	eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1808 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Entity *> >::~_Uninitialized_backout_al<std::allocator<Entity *> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ENDP ; std::_Uninitialized_move<Entity * *,std::allocator<Entity *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$construct@PAVEntity@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@QAPAVEntity@@$$QAPAV3@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVEntity@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@QAPAVEntity@@$$QAPAV3@@Z PROC ; std::_Default_allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity *>, COMDAT

; 673  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 674  : #if _HAS_CXX20
; 675  :         if (_STD is_constant_evaluated()) {
; 676  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 677  :         } else
; 678  : #endif // _HAS_CXX20
; 679  :         {
; 680  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Voidify_iter@PAPAVEntity@@@std@@YAPAXPAPAVEntity@@@Z ; std::_Voidify_iter<Entity * *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 681  :         }
; 682  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@PAVEntity@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@QAPAVEntity@@$$QAPAV3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z PROC ; std::_Unfancy<Entity *>, COMDAT

; 293  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 294  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ENDP ; std::_Unfancy<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Construct_in_place@PAVEntity@@PAV1@@std@@YAXAAPAVEntity@@$$QAPAV1@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAVEntity@@PAV1@@std@@YAXAAPAVEntity@@$$QAPAV1@@Z PROC ; std::_Construct_in_place<Entity *,Entity *>, COMDAT

; 268  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 269  : #if _HAS_CXX20
; 270  :     if (_STD is_constant_evaluated()) {
; 271  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 272  :     } else
; 273  : #endif // _HAS_CXX20
; 274  :     {
; 275  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAVEntity@@@std@@YAPAPAVEntity@@AAPAV1@@Z ; std::addressof<Entity *>
	add	esp, 4
	push	eax
	call	??$_Voidify_iter@PAPAVEntity@@@std@@YAPAXPAPAVEntity@@@Z ; std::_Voidify_iter<Entity * *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 276  :     }
; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PAVEntity@@PAV1@@std@@YAXAAPAVEntity@@$$QAPAV1@@Z ENDP ; std::_Construct_in_place<Entity *,Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z
_TEXT	SEGMENT
__Off$2 = -68						; size = 4
__Target_index$ = -56					; size = 4
__UTarget$ = -44					; size = 4
__ULast$ = -32						; size = 4
__UFirst$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__RngFunc$ = 32						; size = 4
??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z PROC ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rng_from_urng<int,std::_Rand_urng_from_func> >, COMDAT

; 5175 : void _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn& _RngFunc) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4

; 5176 :     // shuffle [_First, _Last) using random function _RngFunc
; 5177 :     _Adl_verify_range(_First, _Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
	add	esp, 8

; 5178 :     auto _UFirst      = _Get_unwrapped(_First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > &>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 5179 :     const auto _ULast = _Get_unwrapped(_Last);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@AAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YA?A_TAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > &>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 5180 :     if (_UFirst == _ULast) {

	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	jne	SHORT $LN11@Random_shu

; 5181 :         return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	jmp	$LN1@Random_shu
$LN11@Random_shu:

; 5182 :     }
; 5183 : 
; 5184 :     using _Diff         = _Iter_diff_t<_RanIt>;
; 5185 :     auto _UTarget       = _UFirst;

	mov	eax, DWORD PTR __UFirst$[ebp]
	mov	DWORD PTR __UTarget$[ebp], eax

; 5186 :     _Diff _Target_index = 1;

	mov	DWORD PTR __Target_index$[ebp], 1

; 5187 :     for (; ++_UTarget != _ULast; ++_Target_index) { // randomly place an element from [_First, _Target] at _Target

	jmp	SHORT $LN4@Random_shu
$LN2@Random_shu:
	mov	eax, DWORD PTR __Target_index$[ebp]
	add	eax, 1
	mov	DWORD PTR __Target_index$[ebp], eax
$LN4@Random_shu:
	mov	eax, DWORD PTR __UTarget$[ebp]
	add	eax, 4
	mov	DWORD PTR __UTarget$[ebp], eax
	mov	ecx, DWORD PTR __UTarget$[ebp]
	cmp	ecx, DWORD PTR __ULast$[ebp]
	je	$LN3@Random_shu

; 5188 :         _Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));

	mov	eax, DWORD PTR __Target_index$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __RngFunc$[ebp]
	call	??R?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAEHH@Z ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::operator()
	mov	DWORD PTR __Off$2[ebp], eax
$LN7@Random_shu:

; 5189 :         _STL_ASSERT(0 <= _Off && _Off <= _Target_index, "random value out of range");

	cmp	DWORD PTR __Off$2[ebp], 0
	jl	SHORT $LN10@Random_shu
	mov	eax, DWORD PTR __Off$2[ebp]
	cmp	eax, DWORD PTR __Target_index$[ebp]
	jg	SHORT $LN10@Random_shu
	jmp	SHORT $LN5@Random_shu
$LN10@Random_shu:
	mov	esi, esp
	push	OFFSET ??_C@_0BK@EIGCDBID@random?5value?5out?5of?5range@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	5189					; 00001445H
	push	OFFSET ??_C@_0GE@GNIOLONC@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN16@Random_shu
	int	3
$LN16@Random_shu:
	mov	esi, esp
	push	0
	push	5189					; 00001445H
	push	OFFSET ??_C@_1MI@NOGIBNK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1DI@PGFAEKLK@?$AA?$CC?$AAr?$AAa?$AAn?$AAd?$AAo?$AAm?$AA?5?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AAo@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN10@Random_shu
$LN5@Random_shu:
	xor	eax, eax
	jne	SHORT $LN7@Random_shu

; 5190 :         if (_Off != _Target_index) { // avoid self-move-assignment

	mov	eax, DWORD PTR __Off$2[ebp]
	cmp	eax, DWORD PTR __Target_index$[ebp]
	je	SHORT $LN14@Random_shu

; 5191 :             _STD iter_swap(_UTarget, _UFirst + _Off);

	mov	eax, DWORD PTR __Off$2[ebp]
	mov	ecx, DWORD PTR __UFirst$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __UTarget$[ebp]
	push	eax
	call	??$iter_swap@PAPAVEntity@@PAPAV1@@std@@YAXPAPAVEntity@@0@Z ; std::iter_swap<Entity * *,Entity * *>
	add	esp, 8
$LN14@Random_shu:

; 5192 :         }
; 5193 :     }

	jmp	$LN2@Random_shu
$LN3@Random_shu:

; 5194 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
$LN1@Random_shu:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z ENDP ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rng_from_urng<int,std::_Rand_urng_from_func> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ?_Get_bits@?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@AAEIXZ
_TEXT	SEGMENT
__Val$1 = -20						; size = 4
_this$ = -8						; size = 4
?_Get_bits@?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@AAEIXZ PROC ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Get_bits, COMDAT
; _this$ = ecx

; 4964 :     _Udiff _Get_bits() { // return a random value within [0, _Bmask]

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4
$LN4@Get_bits:

; 4965 :         for (;;) { // repeat until random value is in range
; 4966 :             const _Udiff _Val = static_cast<_Udiff>(_Ref() - (_Urng::min)());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	??R_Rand_urng_from_func@std@@QAEIXZ	; std::_Rand_urng_from_func::operator()
	mov	esi, eax
	call	?min@_Rand_urng_from_func@std@@SAIXZ	; std::_Rand_urng_from_func::min
	sub	esi, eax
	mov	DWORD PTR __Val$1[ebp], esi

; 4967 : 
; 4968 :             if (_Val <= _Bmask) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$1[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN5@Get_bits

; 4969 :                 return _Val;

	mov	eax, DWORD PTR __Val$1[ebp]
	jmp	SHORT $LN1@Get_bits
$LN5@Get_bits:

; 4970 :             }
; 4971 :         }

	jmp	SHORT $LN4@Get_bits
$LN1@Get_bits:

; 4972 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_bits@?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@AAEIXZ ENDP ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Get_bits
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ??R?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAEHH@Z
_TEXT	SEGMENT
__Mask$1 = -32						; size = 4
__Ret$2 = -20						; size = 4
_this$ = -8						; size = 4
__Index$ = 8						; size = 4
??R?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAEHH@Z PROC ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::operator(), COMDAT
; _this$ = ecx

; 4927 :     _Diff operator()(_Diff _Index) { // adapt _Urng closed range to [0, _Index)

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4
$LN4@operator:

; 4928 :         for (;;) { // try a sample random value
; 4929 :             _Udiff _Ret  = 0; // random bits

	mov	DWORD PTR __Ret$2[ebp], 0

; 4930 :             _Udiff _Mask = 0; // 2^N - 1, _Ret is within [0, _Mask]

	mov	DWORD PTR __Mask$1[ebp], 0
$LN5@operator:

; 4931 : 
; 4932 :             while (_Mask < static_cast<_Udiff>(_Index - 1)) { // need more random bits

	mov	eax, DWORD PTR __Index$[ebp]
	sub	eax, 1
	cmp	DWORD PTR __Mask$1[ebp], eax
	jae	SHORT $LN6@operator

; 4933 :                 _Ret <<= _Bits - 1; // avoid full shift

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR __Ret$2[ebp]
	shl	edx, cl
	mov	DWORD PTR __Ret$2[ebp], edx

; 4934 :                 _Ret <<= 1;

	mov	eax, DWORD PTR __Ret$2[ebp]
	shl	eax, 1
	mov	DWORD PTR __Ret$2[ebp], eax

; 4935 :                 _Ret |= _Get_bits();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_bits@?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@AAEIXZ ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Get_bits
	or	eax, DWORD PTR __Ret$2[ebp]
	mov	DWORD PTR __Ret$2[ebp], eax

; 4936 :                 _Mask <<= _Bits - 1; // avoid full shift

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR __Mask$1[ebp]
	shl	edx, cl
	mov	DWORD PTR __Mask$1[ebp], edx

; 4937 :                 _Mask <<= 1;

	mov	eax, DWORD PTR __Mask$1[ebp]
	shl	eax, 1
	mov	DWORD PTR __Mask$1[ebp], eax

; 4938 :                 _Mask |= _Bmask;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mask$1[ebp]
	or	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Mask$1[ebp], ecx

; 4939 :             }

	jmp	SHORT $LN5@operator
$LN6@operator:

; 4940 : 
; 4941 :             // _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 4942 :             if (_Ret / _Index < _Mask / _Index || _Mask % _Index == static_cast<_Udiff>(_Index - 1)) {

	mov	eax, DWORD PTR __Ret$2[ebp]
	xor	edx, edx
	div	DWORD PTR __Index$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR __Mask$1[ebp]
	xor	edx, edx
	div	DWORD PTR __Index$[ebp]
	cmp	ecx, eax
	jb	SHORT $LN8@operator
	mov	eax, DWORD PTR __Mask$1[ebp]
	xor	edx, edx
	div	DWORD PTR __Index$[ebp]
	mov	eax, DWORD PTR __Index$[ebp]
	sub	eax, 1
	cmp	edx, eax
	jne	SHORT $LN7@operator
$LN8@operator:

; 4943 :                 return static_cast<_Diff>(_Ret % _Index);

	mov	eax, DWORD PTR __Ret$2[ebp]
	xor	edx, edx
	div	DWORD PTR __Index$[ebp]
	mov	eax, edx
	jmp	SHORT $LN1@operator
$LN7@operator:

; 4944 :             }
; 4945 :         }

	jmp	$LN4@operator
$LN1@operator:

; 4946 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??R?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAEHH@Z ENDP ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ??0?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAE@AAU_Rand_urng_from_func@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Func$ = 8						; size = 4
??0?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAE@AAU_Rand_urng_from_func@1@@Z PROC ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Rng_from_urng<int,std::_Rand_urng_from_func>, COMDAT
; _this$ = ecx

; 4921 :         : _Ref(_Func), _Bits(CHAR_BIT * sizeof(_Udiff)), _Bmask(static_cast<_Udiff>(-1)) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Func$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 32			; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], -1

; 4922 :         for (; static_cast<_Udiff>((_Urng::max)() - (_Urng::min)()) < _Bmask; _Bmask >>= 1) {

	jmp	SHORT $LN4@Rng_from_u
$LN2@Rng_from_u:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN4@Rng_from_u:
	call	?max@_Rand_urng_from_func@std@@SAIXZ	; std::_Rand_urng_from_func::max
	mov	esi, eax
	call	?min@_Rand_urng_from_func@std@@SAIXZ	; std::_Rand_urng_from_func::min
	sub	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	cmp	esi, DWORD PTR [eax+8]
	jae	SHORT $LN1@Rng_from_u

; 4923 :             --_Bits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 4924 :         }

	jmp	SHORT $LN2@Rng_from_u
$LN1@Rng_from_u:

; 4925 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAE@AAU_Rand_urng_from_func@1@@Z ENDP ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Rng_from_urng<int,std::_Rand_urng_from_func>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??$hash_combine_impl@M@@YAXAAIABM@Z
_TEXT	SEGMENT
_hasher$ = -9						; size = 1
__$ArrayPad$ = -4					; size = 4
_seed$ = 8						; size = 4
_v$ = 12						; size = 4
??$hash_combine_impl@M@@YAXAAIABM@Z PROC		; hash_combine_impl<float>, COMDAT

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 7    :     std::hash<T> hasher;
; 8    :     seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);

	mov	eax, DWORD PTR _v$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _hasher$[ebp]
	call	??R?$hash@M@std@@QBEIM@Z		; std::hash<float>::operator()
	mov	ecx, DWORD PTR _seed$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 6
	lea	eax, DWORD PTR [eax+edx-1640531527]
	mov	ecx, DWORD PTR _seed$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 2
	add	eax, edx
	mov	ecx, DWORD PTR _seed$[ebp]
	xor	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _seed$[ebp]
	mov	DWORD PTR [edx], eax

; 9    : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@hash_combi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN5@hash_combi:
	DD	1
	DD	$LN4@hash_combi
$LN4@hash_combi:
	DD	-9					; fffffff7H
	DD	1
	DD	$LN3@hash_combi
$LN3@hash_combi:
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
??$hash_combine_impl@M@@YAXAAIABM@Z ENDP		; hash_combine_impl<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CM@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0CM@@std@@YAII@Z PROC		; std::_Get_size_of_n<44>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 97612893 ; 05d1745dH

; 60   :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 97612893	; 05d1745dH
	jbe	SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	imul	eax, DWORD PTR __Count$[ebp], 44
$LN3@Get_size_o:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$0CM@@std@@YAII@Z ENDP		; std::_Get_size_of_n<44>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0DA@@std@@YAII@Z PROC		; std::_Get_size_of_n<48>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 89478485 ; 05555555H

; 60   :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 89478485	; 05555555H
	jbe	SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	imul	eax, DWORD PTR __Count$[ebp], 48
$LN3@Get_size_o:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$0DA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<48>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$destroy@VPlayer@@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@VPlayer@@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@@Z PROC ; std::_Default_allocator_traits<std::allocator<Player> >::destroy<Player>, COMDAT

; 685  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 686  : #if _HAS_CXX20
; 687  :         _STD destroy_at(_Ptr);
; 688  : #else // _HAS_CXX20
; 689  :         _Ptr->~_Uty();

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 690  : #endif // _HAS_CXX20
; 691  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@VPlayer@@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Player> >::destroy<Player>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$_Unfancy@VPlayer@@@std@@YAPAVPlayer@@PAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@VPlayer@@@std@@YAPAVPlayer@@PAV1@@Z PROC	; std::_Unfancy<Player>, COMDAT

; 293  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 294  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@VPlayer@@@std@@YAPAVPlayer@@PAV1@@Z ENDP	; std::_Unfancy<Player>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$destroy@VEnemy@@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@VEnemy@@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@@Z PROC ; std::_Default_allocator_traits<std::allocator<Enemy> >::destroy<Enemy>, COMDAT

; 685  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 686  : #if _HAS_CXX20
; 687  :         _STD destroy_at(_Ptr);
; 688  : #else // _HAS_CXX20
; 689  :         _Ptr->~_Uty();

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 690  : #endif // _HAS_CXX20
; 691  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@VEnemy@@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Enemy> >::destroy<Enemy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$_Unfancy@VEnemy@@@std@@YAPAVEnemy@@PAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@VEnemy@@@std@@YAPAVEnemy@@PAV1@@Z PROC	; std::_Unfancy<Enemy>, COMDAT

; 293  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 294  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@VEnemy@@@std@@YAPAVEnemy@@PAV1@@Z ENDP	; std::_Unfancy<Enemy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z
_TEXT	SEGMENT
$T2 = -272						; size = 4
__Backout$ = -68					; size = 12
__Can_memmove$ = -45					; size = 1
__ULast$ = -36						; size = 4
__UFirst$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z PROC ; std::_Uninitialized_copy<Player const *,Player const *,std::allocator<Player> >, COMDAT

; 1677 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1678 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1679 :     // note: only called internally from elsewhere in the STL
; 1680 :     using _Ptrval = typename _Alloc::value_type*;
; 1681 : 
; 1682 : #ifdef __cpp_lib_concepts
; 1683 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1684 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1685 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1686 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1687 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1688 :     auto _UFirst = _Get_unwrapped(_STD move(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@PBVPlayer@@@std@@YA?A_T$$QAPBVPlayer@@@Z ; std::_Get_unwrapped<Player const *>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1689 :     auto _ULast = _Get_unwrapped(_STD move(_Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@PBVPlayer@@@std@@YA?A_T$$QAPBVPlayer@@@Z ; std::_Get_unwrapped<Player const *>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 1690 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1691 : 
; 1692 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible

	mov	BYTE PTR __Can_memmove$[ebp], 0

; 1693 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1694 : 
; 1695 :     if constexpr (_Can_memmove) {
; 1696 : #if _HAS_CXX20
; 1697 :         if (!_STD is_constant_evaluated())
; 1698 : #endif // _HAS_CXX20
; 1699 :         {
; 1700 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1701 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1702 :                 _Dest += _ULast - _UFirst;
; 1703 :             } else {
; 1704 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1705 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1706 :                 _Dest += _Count;
; 1707 :             }
; 1708 :             return _Dest;
; 1709 :         }
; 1710 :     }
; 1711 : 
; 1712 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	push	12					; 0000000cH
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@PAVPlayer@@AAV?$allocator@VPlayer@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Uninitialized_backout_al<std::allocator<Player> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1713 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@Uninitiali

; 1714 :         _Backout._Emplace_back(*_UFirst);

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@ABVPlayer@@@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEXABVPlayer@@@Z ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Emplace_back<Player const &>

; 1715 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1716 : 
; 1717 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ; std::_Uninitialized_backout_al<std::allocator<Player> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Player> >::~_Uninitialized_backout_al<std::allocator<Player> >
	mov	eax, DWORD PTR $T2[ebp]

; 1718 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-68					; ffffffbcH
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Player> >::~_Uninitialized_backout_al<std::allocator<Player> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z ENDP ; std::_Uninitialized_copy<Player const *,Player const *,std::allocator<Player> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Tidy_guard@V?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<Player,std::allocator<Player> > >::~_Tidy_guard<std::vector<Player,std::allocator<Player> > >, COMDAT
; _this$ = ecx

; 33   :     _CONSTEXPR20 ~_Tidy_guard() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 34   :         if (_Target) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy_guard

; 35   :             _Target->_Tidy();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ ; std::vector<Player,std::allocator<Player> >::_Tidy
$LN3@Tidy_guard:

; 36   :         }
; 37   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tidy_guard@V?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<Player,std::allocator<Player> > >::~_Tidy_guard<std::vector<Player,std::allocator<Player> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z
_TEXT	SEGMENT
$T2 = -272						; size = 4
__Backout$ = -68					; size = 12
__Can_memmove$ = -45					; size = 1
__ULast$ = -36						; size = 4
__UFirst$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z PROC ; std::_Uninitialized_copy<Enemy const *,Enemy const *,std::allocator<Enemy> >, COMDAT

; 1677 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1678 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1679 :     // note: only called internally from elsewhere in the STL
; 1680 :     using _Ptrval = typename _Alloc::value_type*;
; 1681 : 
; 1682 : #ifdef __cpp_lib_concepts
; 1683 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1684 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1685 : #else // ^^^ __cpp_lib_concepts / !__cpp_lib_concepts vvv
; 1686 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1687 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1688 :     auto _UFirst = _Get_unwrapped(_STD move(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Get_unwrapped@PBVEnemy@@@std@@YA?A_T$$QAPBVEnemy@@@Z ; std::_Get_unwrapped<Enemy const *>
	add	esp, 4
	mov	DWORD PTR __UFirst$[ebp], eax

; 1689 :     auto _ULast = _Get_unwrapped(_STD move(_Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Get_unwrapped@PBVEnemy@@@std@@YA?A_T$$QAPBVEnemy@@@Z ; std::_Get_unwrapped<Enemy const *>
	add	esp, 4
	mov	DWORD PTR __ULast$[ebp], eax

; 1690 : #endif // ^^^ !__cpp_lib_concepts ^^^
; 1691 : 
; 1692 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible

	mov	BYTE PTR __Can_memmove$[ebp], 0

; 1693 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1694 : 
; 1695 :     if constexpr (_Can_memmove) {
; 1696 : #if _HAS_CXX20
; 1697 :         if (!_STD is_constant_evaluated())
; 1698 : #endif // _HAS_CXX20
; 1699 :         {
; 1700 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1701 :                 _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
; 1702 :                 _Dest += _ULast - _UFirst;
; 1703 :             } else {
; 1704 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1705 :                 _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
; 1706 :                 _Dest += _Count;
; 1707 :             }
; 1708 :             return _Dest;
; 1709 :         }
; 1710 :     }
; 1711 : 
; 1712 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

	push	12					; 0000000cH
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??0?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@PAVEnemy@@AAV?$allocator@VEnemy@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Uninitialized_backout_al<std::allocator<Enemy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1713 :     for (; _UFirst != _ULast; ++_UFirst) {

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
	mov	eax, DWORD PTR __UFirst$[ebp]
	cmp	eax, DWORD PTR __ULast$[ebp]
	je	SHORT $LN3@Uninitiali

; 1714 :         _Backout._Emplace_back(*_UFirst);

	mov	eax, DWORD PTR __UFirst$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??$_Emplace_back@ABVEnemy@@@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEXABVEnemy@@@Z ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Emplace_back<Enemy const &>

; 1715 :     }

	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1716 : 
; 1717 :     return _Backout._Release();

	lea	ecx, DWORD PTR __Backout$[ebp]
	call	?_Release@?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::_Release
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Backout$[ebp]
	call	??1?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::~_Uninitialized_backout_al<std::allocator<Enemy> >
	mov	eax, DWORD PTR $T2[ebp]

; 1718 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Uninitiali
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@Uninitiali:
	DD	1
	DD	$LN9@Uninitiali
$LN9@Uninitiali:
	DD	-68					; ffffffbcH
	DD	12					; 0000000cH
	DD	$LN7@Uninitiali
$LN7@Uninitiali:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z$0:
	lea	ecx, DWORD PTR __Backout$[ebp]
	jmp	??1?$_Uninitialized_backout_al@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<Enemy> >::~_Uninitialized_backout_al<std::allocator<Enemy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z ENDP ; std::_Uninitialized_copy<Enemy const *,Enemy const *,std::allocator<Enemy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Tidy_guard@V?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >::~_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >, COMDAT
; _this$ = ecx

; 33   :     _CONSTEXPR20 ~_Tidy_guard() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 34   :         if (_Target) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy_guard

; 35   :             _Target->_Tidy();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ ; std::vector<Enemy,std::allocator<Enemy> >::_Tidy
$LN3@Tidy_guard:

; 36   :         }
; 37   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tidy_guard@V?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >::~_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -156				; size = 4
__Constructed_last$ = -144				; size = 4
__Newvec$ = -132					; size = 4
__Newcapacity$ = -120					; size = 4
__Newsize$ = -108					; size = 4
__Oldsize$ = -96					; size = 4
__Whereoff$ = -84					; size = 4
__Mylast$ = -72						; size = 4
__Myfirst$ = -60					; size = 4
__My_data$ = -48					; size = 4
__Al$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_reallocate<Entity *>, COMDAT
; _this$ = ecx

; 875  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 876  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 877  :         _Alty& _Al        = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 878  :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 879  :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 880  :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 881  : 
; 882  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 883  : 
; 884  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	mov	DWORD PTR __Whereoff$[ebp], ecx

; 885  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	mov	DWORD PTR __Oldsize$[ebp], edx

; 886  : 
; 887  :         if (_Oldsize == max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::max_size
	cmp	DWORD PTR __Oldsize$[ebp], eax
	jne	SHORT $LN2@Emplace_re

; 888  :             _Xlength();

	call	?_Xlength@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@CAXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Xlength
$LN2@Emplace_re:

; 889  :         }
; 890  : 
; 891  :         const size_type _Newsize     = _Oldsize + 1;

	mov	eax, DWORD PTR __Oldsize$[ebp]
	add	eax, 1
	mov	DWORD PTR __Newsize$[ebp], eax

; 892  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEII@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Calculate_growth
	mov	DWORD PTR __Newcapacity$[ebp], eax

; 893  : 
; 894  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z ; std::allocator<Entity *>::allocate
	mov	DWORD PTR __Newvec$[ebp], eax

; 895  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

	mov	eax, DWORD PTR __Whereoff$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR __Constructed_last$[ebp], edx

; 896  :         pointer _Constructed_first      = _Constructed_last;

	mov	eax, DWORD PTR __Constructed_last$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 897  : 
; 898  :         _TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 899  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$[ebp]
	mov	edx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unfancy<Entity *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$construct@PAVEntity@@PAV1@@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAXAAV?$allocator@PAVEntity@@@1@QAPAVEntity@@$$QAPAV3@@Z ; std::_Default_allocator_traits<std::allocator<Entity *> >::construct<Entity *,Entity *>
	add	esp, 12					; 0000000cH

; 900  :         _Constructed_first = _Newvec + _Whereoff;

	mov	eax, DWORD PTR __Whereoff$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Constructed_first$[ebp], edx

; 901  : 
; 902  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Whereptr$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@Emplace_re

; 903  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 904  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Uninitialized_move<Entity * *,std::allocator<Entity *> >
	add	esp, 16					; 00000010H

; 905  :             } else {
; 906  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 907  :             }
; 908  :         } else { // provide basic guarantee

	jmp	SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 909  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Whereptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Uninitialized_move<Entity * *,std::allocator<Entity *> >
	add	esp, 16					; 00000010H

; 910  :             _Constructed_first = _Newvec;

	mov	eax, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR __Constructed_first$[ebp], eax

; 911  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$[ebp]
	mov	edx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Whereptr$[ebp]
	push	eax
	call	??$_Uninitialized_move@PAPAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@YAPAPAVEntity@@QAPAV1@0PAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Uninitialized_move<Entity * *,std::allocator<Entity *> >
	add	esp, 16					; 00000010H
$LN5@Emplace_re:
	jmp	SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z$0:

; 912  :         }
; 913  :         _CATCH_ALL
; 914  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Constructed_last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Constructed_first$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Destroy_range<std::allocator<Entity *> >
	add	esp, 12					; 0000000cH

; 915  :         _Al.deallocate(_Newvec, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@PAVEntity@@@std@@QAEXQAPAVEntity@@I@Z ; std::allocator<Entity *>::deallocate

; 916  :         _RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 917  :         _CATCH_END

	mov	eax, $LN10@Emplace_re
	ret	0
$LN7@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z$1
$LN10@Emplace_re:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z$1:

; 918  : 
; 919  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Change_array@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXQAPAVEntity@@II@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Change_array

; 920  :         return _Newvec + _Whereoff;

	mov	eax, DWORD PTR __Whereoff$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
$LN6@Emplace_re:

; 921  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 352				; 00000160H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_reallocate<Entity *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_back_with_unused_capacity<Entity *>, COMDAT
; _this$ = ecx

; 852  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 853  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 854  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 855  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 856  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 857  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 858  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 859  :             _ASAN_VECTOR_MODIFY(1);
; 860  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$_Construct_in_place@PAVEntity@@PAV1@@std@@YAXAAPAVEntity@@$$QAPAV1@@Z ; std::_Construct_in_place<Entity *,Entity *>
	add	esp, 8

; 861  :         } else {
; 862  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 863  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 864  :             _ASAN_VECTOR_RELEASE_GUARD;
; 865  :         }
; 866  : 
; 867  :         _Orphan_range(_Mylast, _Mylast);

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range

; 868  :         _Ty& _Result = *_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Result$[ebp], ecx

; 869  :         ++_Mylast;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [edx], ecx

; 870  : 
; 871  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 872  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_back_with_unused_capacity@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_back_with_unused_capacity<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z
_TEXT	SEGMENT
$T2 = -248						; size = 4
$T3 = -236						; size = 4
__RngFunc$ = -32					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Func$ = 32						; size = 4
??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z PROC ; std::shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rand_urng_from_func &>, COMDAT

; 5197 : void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func) { // shuffle [_First, _Last) using URNG _Func

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4

; 5198 :     using _Urng0 = remove_reference_t<_Urng>;
; 5199 :     _Rng_from_urng<_Iter_diff_t<_RanIt>, _Urng0> _RngFunc(_Func);

	mov	eax, DWORD PTR __Func$[ebp]
	push	eax
	lea	ecx, DWORD PTR __RngFunc$[ebp]
	call	??0?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@std@@QAE@AAU_Rand_urng_from_func@1@@Z ; std::_Rng_from_urng<int,std::_Rand_urng_from_func>::_Rng_from_urng<int,std::_Rand_urng_from_func>

; 5200 :     _Random_shuffle1(_First, _Last, _RngFunc);

	lea	eax, DWORD PTR __RngFunc$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	call	??$_Random_shuffle1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@V?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAV?$_Rng_from_urng@HU_Rand_urng_from_func@std@@@0@@Z ; std::_Random_shuffle1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rng_from_urng<int,std::_Rand_urng_from_func> >
	add	esp, 28					; 0000001cH

; 5201 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@shuffle
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@shuffle:
	DD	1
	DD	$LN9@shuffle
$LN9@shuffle:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$LN7@shuffle
$LN7@shuffle:
	DB	95					; 0000005fH
	DB	82					; 00000052H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	70					; 00000046H
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z ENDP ; std::shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rand_urng_from_func &>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
_TEXT	SEGMENT
tv405 = -332						; size = 8
tv290 = -324						; size = 4
tv287 = -324						; size = 8
tv285 = -324						; size = 4
tv324 = -320						; size = 8
tv289 = -320						; size = 4
tv284 = -320						; size = 4
tv286 = -316						; size = 4
tv135 = -316						; size = 4
tv288 = -313						; size = 1
tv283 = -313						; size = 1
$T2 = -308						; size = 4
$T3 = -296						; size = 4
$T4 = -284						; size = 4
$T5 = -272						; size = 4
$T6 = -260						; size = 4
__Ok$ = -56						; size = 8
__Pad$ = -40						; size = 4
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Data$ = 12						; size = 4
__Size$ = 16						; size = 4
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned int>, COMDAT

; 506  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 316				; 0000013cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 31					; 0000001fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 507  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 508  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 509  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 510  : 
; 511  :     _SizeT _Pad;
; 512  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv324[ebp], eax
	mov	DWORD PTR tv324[ebp+4], edx
	cmp	DWORD PTR tv324[ebp+4], 0
	jl	SHORT $LN10@Insert_str
	jg	SHORT $LN25@Insert_str
	cmp	DWORD PTR tv324[ebp], 0
	jbe	SHORT $LN10@Insert_str
$LN25@Insert_str:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, DWORD PTR __Size$[ebp]
	ja	SHORT $LN8@Insert_str
$LN10@Insert_str:

; 513  :         _Pad = 0;

	mov	DWORD PTR __Pad$[ebp], 0

; 514  :     } else {

	jmp	SHORT $LN9@Insert_str
$LN8@Insert_str:

; 515  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Pad$[ebp], eax
$LN9@Insert_str:

; 516  :     }
; 517  : 
; 518  :     const typename _Ostr_t::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 519  : 
; 520  :     if (!_Ok) {

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@Insert_str

; 521  :         _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 522  :     } else { // state okay, insert characters

	jmp	$LN12@Insert_str
$LN11@Insert_str:

; 523  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 524  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv135[ebp], eax
	mov	eax, DWORD PTR tv135[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN14@Insert_str

; 525  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@Insert_str
$LN2@Insert_str:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN4@Insert_str:
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN14@Insert_str

; 526  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv283[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv284[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv283[ebp]
	push	eax
	mov	ecx, DWORD PTR tv284[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	ecx, DWORD PTR tv285[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Insert_str

; 527  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 528  :                     break;

	jmp	SHORT $LN14@Insert_str
$LN15@Insert_str:

; 529  :                 }
; 530  :             }

	jmp	$LN2@Insert_str
$LN14@Insert_str:

; 531  :         }
; 532  : 
; 533  :         if (_State == _Ostr_t::goodbit
; 534  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN16@Insert_str
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv286[ebp], eax
	mov	eax, DWORD PTR __Size$[ebp]
	xor	ecx, ecx
	mov	esi, esp
	push	ecx
	push	eax
	mov	edx, DWORD PTR __Data$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv286[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	DWORD PTR tv287[ebp+4], edx
	mov	eax, DWORD PTR __Size$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv405[ebp], eax
	mov	DWORD PTR tv405[ebp+4], ecx
	mov	edx, DWORD PTR tv287[ebp]
	cmp	edx, DWORD PTR tv405[ebp]
	jne	SHORT $LN26@Insert_str
	mov	eax, DWORD PTR tv287[ebp+4]
	cmp	eax, DWORD PTR tv405[ebp+4]
	je	SHORT $LN16@Insert_str
$LN26@Insert_str:

; 535  :             _State |= _Ostr_t::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 536  :         } else {

	jmp	$LN17@Insert_str
$LN16@Insert_str:

; 537  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@Insert_str
$LN5@Insert_str:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Pad$[ebp], eax
$LN7@Insert_str:
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN17@Insert_str

; 538  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv288[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv289[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv288[ebp]
	push	eax
	mov	ecx, DWORD PTR tv289[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	ecx, DWORD PTR tv290[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@Insert_str

; 539  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 540  :                     break;

	jmp	SHORT $LN17@Insert_str
$LN18@Insert_str:

; 541  :                 }
; 542  :             }

	jmp	$LN5@Insert_str
$LN17@Insert_str:

; 543  :         }
; 544  : 
; 545  :         _Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN20@Insert_str
__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0:

; 546  :         _CATCH_IO_(_Ostr_t, _Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN24@Insert_str
	ret	0
$LN20@Insert_str:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN12@Insert_str
$LN24@Insert_str:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN12@Insert_str:

; 547  :     }
; 548  : 
; 549  :     _Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 550  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 551  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@Insert_str
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN30@Insert_str:
	DD	1
	DD	$LN29@Insert_str
$LN29@Insert_str:
	DD	-56					; ffffffc8H
	DD	8
	DD	$LN27@Insert_str
$LN27@Insert_str:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-336]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??$hash_combine_impl@MM@@YAXAAIABM1@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
_v$ = 12						; size = 4
_<args_0>$ = 16						; size = 4
??$hash_combine_impl@MM@@YAXAAIABM1@Z PROC		; hash_combine_impl<float,float>, COMDAT

; 14   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 15   :     hash_combine_impl(seed, args...);

	mov	eax, DWORD PTR _<args_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _seed$[ebp]
	push	ecx
	call	??$hash_combine_impl@M@@YAXAAIABM@Z	; hash_combine_impl<float>
	add	esp, 8

; 16   :     hash_combine_impl(seed, v);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _seed$[ebp]
	push	ecx
	call	??$hash_combine_impl@M@@YAXAAIABM@Z	; hash_combine_impl<float>
	add	esp, 8

; 17   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$hash_combine_impl@MM@@YAXAAIABM1@Z ENDP		; hash_combine_impl<float,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Player> >, COMDAT

; 942  : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 943  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 944  :     using _Ty = typename _Alloc::value_type;
; 945  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 946  :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN5@Destroy_ra

; 947  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unfancy@VPlayer@@@std@@YAPAVPlayer@@PAV1@@Z ; std::_Unfancy<Player>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$destroy@VPlayer@@@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAXAAV?$allocator@VPlayer@@@1@QAVPlayer@@@Z ; std::_Default_allocator_traits<std::allocator<Player> >::destroy<Player>
	add	esp, 8

; 948  :         }

	jmp	SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 949  :     }
; 950  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Player> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Enemy> >, COMDAT

; 942  : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 943  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 944  :     using _Ty = typename _Alloc::value_type;
; 945  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 946  :         for (; _First != _Last; ++_First) {

	jmp	SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN5@Destroy_ra

; 947  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unfancy@VEnemy@@@std@@YAPAVEnemy@@PAV1@@Z ; std::_Unfancy<Enemy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$destroy@VEnemy@@@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAXAAV?$allocator@VEnemy@@@1@QAVEnemy@@@Z ; std::_Default_allocator_traits<std::allocator<Enemy> >::destroy<Enemy>
	add	esp, 8

; 948  :         }

	jmp	SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 949  :     }
; 950  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Enemy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Entity *> >, COMDAT

; 942  : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 943  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 944  :     using _Ty = typename _Alloc::value_type;
; 945  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 946  :         for (; _First != _Last; ++_First) {
; 947  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 948  :         }
; 949  :     }
; 950  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 123  :         explicit __CLR_OR_THIS_CALL operator bool() const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __47FEFEA8_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 124  :             return _Ok;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+4]

; 125  :         }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -229						; size = 1
__Zero_uncaught_exceptions$ = -29			; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __47FEFEA8_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@sentry
	mov	BYTE PTR tv72[ebp], 1
	jmp	SHORT $LN5@sentry
$LN4@sentry:
	mov	BYTE PTR tv72[ebp], 0
$LN5@sentry:
	mov	cl, BYTE PTR tv72[ebp]
	mov	BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

	movzx	eax, BYTE PTR __Zero_uncaught_exceptions$[ebp]
	test	eax, eax
	je	SHORT $LN1@sentry

; 118  :                 this->_Myostr._Osfx();

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@sentry:

; 119  :             }
; 120  :         }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __47FEFEA8_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 92   :             if (!_Ostr.good()) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 93   :                 _Ok = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 94   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:

; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Tied$[ebp], eax

; 98   :             if (!_Tied || _Tied == &_Ostr) {

	cmp	DWORD PTR __Tied$[ebp], 0
	je	SHORT $LN4@sentry
	mov	eax, DWORD PTR __Tied$[ebp]
	cmp	eax, DWORD PTR __Ostr$[ebp]
	jne	SHORT $LN3@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 1

; 100  :                 return;

	jmp	SHORT $LN1@sentry
$LN3@sentry:

; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Tied$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al
$LN1@sentry:

; 105  :         }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __47FEFEA8_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 79   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN3@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Sentry_bas:

; 81   :             }
; 82   :         }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __47FEFEA8_ostream
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv73[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Rdbuf$[ebp], eax

; 72   :             if (_Rdbuf) {

	cmp	DWORD PTR __Rdbuf$[ebp], 0
	je	SHORT $LN1@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

	mov	eax, DWORD PTR __Rdbuf$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR __Rdbuf$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Sentry_bas:

; 74   :             }
; 75   :         }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z
_TEXT	SEGMENT
__Guard$2 = -100					; size = 4
__Proxy$ = -88						; size = 8
__My_data$ = -72					; size = 4
_$S18$ = -57						; size = 1
__Alproxy$ = -48					; size = 4
__Al$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
_<_Val_1>$ = 16						; size = 4
??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z PROC ; std::vector<Player,std::allocator<Player> >::_Construct_n<Player const *,Player const *>, COMDAT
; _this$ = ecx

; 2119 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2120 :         // Dispatches between the three sized constructions.
; 2121 :         // 1-arg -> value-construction, e.g. vector(5)
; 2122 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2123 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2124 :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ ; std::vector<Player,std::allocator<Player> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2125 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	lea	ecx, DWORD PTR _$S18$[ebp]
	call	??$?0VPlayer@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VPlayer@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Player>
	lea	ecx, DWORD PTR _$S18$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], ecx

; 2126 :         auto& _My_data  = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2127 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2128 :         if (_Count != 0) {

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN2@Construct_

; 2129 :             _Buy_nonzero(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy_nonzero@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z ; std::vector<Player,std::allocator<Player> >::_Buy_nonzero

; 2130 :             _Tidy_guard<vector> _Guard{this};

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Guard$2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2131 :             if constexpr (sizeof...(_Val) == 0) {
; 2132 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
; 2133 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2134 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2135 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2136 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2137 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _<_Val_1>$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Uninitialized_copy@PBVPlayer@@PBV1@V?$allocator@VPlayer@@@std@@@std@@YAPAVPlayer@@PBV1@0PAV1@AAV?$allocator@VPlayer@@@0@@Z ; std::_Uninitialized_copy<Player const *,Player const *,std::allocator<Player> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2138 :             } else {
; 2139 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2140 :             }
; 2141 :             _ASAN_VECTOR_CREATE;
; 2142 :             _Guard._Target = nullptr;

	mov	DWORD PTR __Guard$2[ebp], 0

; 2143 :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Guard$2[ebp]
	call	??1?$_Tidy_guard@V?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<Player,std::allocator<Player> > >::~_Tidy_guard<std::vector<Player,std::allocator<Player> > >
$LN2@Construct_:

; 2144 : 
; 2145 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2146 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Construct_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN11@Construct_:
	DD	3
	DD	$LN10@Construct_
$LN10@Construct_:
	DD	-57					; ffffffc7H
	DD	1
	DD	$LN6@Construct_
	DD	-88					; ffffffa8H
	DD	8
	DD	$LN7@Construct_
	DD	-100					; ffffff9cH
	DD	4
	DD	$LN8@Construct_
$LN8@Construct_:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN7@Construct_:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct_:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	56					; 00000038H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z$1:
	lea	ecx, DWORD PTR __Guard$2[ebp]
	jmp	??1?$_Tidy_guard@V?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<Player,std::allocator<Player> > >::~_Tidy_guard<std::vector<Player,std::allocator<Player> > >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-300]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z ENDP ; std::vector<Player,std::allocator<Player> >::_Construct_n<Player const *,Player const *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0ABV?$allocator@VPlayer@@@std@@$$V@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VPlayer@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@VPlayer@@@std@@$$V@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VPlayer@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1><std::allocator<Player> const &>, COMDAT
; _this$ = ecx

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Player> >::_Vector_val<std::_Simple_types<Player> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0ABV?$allocator@VPlayer@@@std@@$$V@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VPlayer@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1><std::allocator<Player> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0VPlayer@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VPlayer@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0VPlayer@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VPlayer@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Player>, COMDAT
; _this$ = ecx

; 822  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0VPlayer@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VPlayer@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Player>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z
_TEXT	SEGMENT
__Guard$2 = -100					; size = 4
__Proxy$ = -88						; size = 8
__My_data$ = -72					; size = 4
_$S17$ = -57						; size = 1
__Alproxy$ = -48					; size = 4
__Al$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
_<_Val_1>$ = 16						; size = 4
??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Construct_n<Enemy const *,Enemy const *>, COMDAT
; _this$ = ecx

; 2119 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 23					; 00000017H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2120 :         // Dispatches between the three sized constructions.
; 2121 :         // 1-arg -> value-construction, e.g. vector(5)
; 2122 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2123 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2124 :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2125 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	lea	ecx, DWORD PTR _$S17$[ebp]
	call	??$?0VEnemy@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VEnemy@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Enemy>
	lea	ecx, DWORD PTR _$S17$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], ecx

; 2126 :         auto& _My_data  = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2127 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2128 :         if (_Count != 0) {

	cmp	DWORD PTR __Count$[ebp], 0
	je	SHORT $LN2@Construct_

; 2129 :             _Buy_nonzero(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy_nonzero@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_nonzero

; 2130 :             _Tidy_guard<vector> _Guard{this};

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Guard$2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2131 :             if constexpr (sizeof...(_Val) == 0) {
; 2132 :                 _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
; 2133 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2134 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2135 :                 _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2136 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2137 :                 _My_data._Mylast = _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _<_Val_1>$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Uninitialized_copy@PBVEnemy@@PBV1@V?$allocator@VEnemy@@@std@@@std@@YAPAVEnemy@@PBV1@0PAV1@AAV?$allocator@VEnemy@@@0@@Z ; std::_Uninitialized_copy<Enemy const *,Enemy const *,std::allocator<Enemy> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2138 :             } else {
; 2139 :                 static_assert(_Always_false<_Ty>, "Should be unreachable");
; 2140 :             }
; 2141 :             _ASAN_VECTOR_CREATE;
; 2142 :             _Guard._Target = nullptr;

	mov	DWORD PTR __Guard$2[ebp], 0

; 2143 :         }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Guard$2[ebp]
	call	??1?$_Tidy_guard@V?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >::~_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >
$LN2@Construct_:

; 2144 : 
; 2145 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2146 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Construct_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 296				; 00000128H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN11@Construct_:
	DD	3
	DD	$LN10@Construct_
$LN10@Construct_:
	DD	-57					; ffffffc7H
	DD	1
	DD	$LN6@Construct_
	DD	-88					; ffffffa8H
	DD	8
	DD	$LN7@Construct_
	DD	-100					; ffffff9cH
	DD	4
	DD	$LN8@Construct_
$LN8@Construct_:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$LN7@Construct_:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct_:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	55					; 00000037H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z$1:
	lea	ecx, DWORD PTR __Guard$2[ebp]
	jmp	??1?$_Tidy_guard@V?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >::~_Tidy_guard<std::vector<Enemy,std::allocator<Enemy> > >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-300]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Construct_n<Enemy const *,Enemy const *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0ABV?$allocator@VEnemy@@@std@@$$V@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VEnemy@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@VEnemy@@@std@@$$V@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VEnemy@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1><std::allocator<Enemy> const &>, COMDAT
; _this$ = ecx

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Enemy> >::_Vector_val<std::_Simple_types<Enemy> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0ABV?$allocator@VEnemy@@@std@@$$V@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VEnemy@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1><std::allocator<Enemy> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0VEnemy@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VEnemy@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0VEnemy@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VEnemy@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Enemy>, COMDAT
; _this$ = ecx

; 822  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0VEnemy@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VEnemy@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Enemy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1><>, COMDAT
; _this$ = ecx

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAVEntity@@@std@@QAE@XZ	; std::allocator<Entity *>::allocator<Entity *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 652  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9596B502_utility
	call	@__CheckForDebuggerJustMyCode@4

; 653  :     // assign _New_val to _Val, return previous _Val
; 654  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 655  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 656  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 657  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>, COMDAT
; _this$ = ecx

; 822  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??$_Emplace_one_at_back@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z
_TEXT	SEGMENT
__Mylast$ = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_one_at_back<Entity *>, COMDAT
; _this$ = ecx

; 839  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 840  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 841  :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 842  :         pointer& _Mylast = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 843  : 
; 844  :         if (_Mylast != _My_data._Myend) {

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN2@Emplace_on

; 845  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_back_with_unused_capacity@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_back_with_unused_capacity<Entity *>
	jmp	SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 846  :         }
; 847  : 
; 848  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_reallocate@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEPAPAVEntity@@QAPAV2@$$QAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_reallocate<Entity *>
$LN1@Emplace_on:

; 849  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Emplace_one_at_back@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_one_at_back<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT

; 280  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 282  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
$T2 = -240						; size = 4
$T3 = -228						; size = 4
__Func$ = -21						; size = 1
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z PROC ; std::random_shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >, COMDAT

; 5285 : void random_shuffle(_RanIt _First, _RanIt _Last) { // shuffle [_First, _Last) using rand()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4

; 5286 :     _Rand_urng_from_func _Func;
; 5287 :     _STD shuffle(_First, _Last, _Func);

	lea	eax, DWORD PTR __Func$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	call	??$shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@AAU_Rand_urng_from_func@2@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0AAU_Rand_urng_from_func@0@@Z ; std::shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >,std::_Rand_urng_from_func &>
	add	esp, 28					; 0000001cH

; 5288 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@random_shu
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN10@random_shu:
	DD	1
	DD	$LN9@random_shu
$LN9@random_shu:
	DD	-21					; ffffffebH
	DD	1
	DD	$LN7@random_shu
$LN7@random_shu:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z ENDP ; std::random_shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___param1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___param0$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 333  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 334  :         return _Unfancy(this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$_Unfancy@PAVEntity@@@std@@YAPAPAVEntity@@PAPAV1@@Z ; std::_Unfancy<Entity *>
	add	esp, 4

; 335  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QBEPAPAVEntity@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0@Z PROC ; std::_Verify_range, COMDAT

; 198  :         const _Vector_const_iterator& _First, const _Vector_const_iterator& _Last) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
$LN4@Verify_ran:

; 199  :         _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "vector iterators in range are from different containers");

	mov	ecx, DWORD PTR __First$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Last$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	jne	SHORT $LN7@Verify_ran
	jmp	SHORT $LN2@Verify_ran
$LN7@Verify_ran:
	mov	esi, esp
	push	OFFSET ??_C@_0DI@PBEELKIF@vector?5iterators?5in?5range?5are?5f@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	199					; 000000c7H
	push	OFFSET ??_C@_0GB@NEMOGBCE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Verify_ran
	int	3
$LN19@Verify_ran:
	mov	esi, esp
	push	0
	push	199					; 000000c7H
	push	OFFSET ??_C@_1MC@BDGGHEJF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HE@KBMFDAFB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Verify_ran
$LN2@Verify_ran:
	xor	eax, eax
	jne	SHORT $LN4@Verify_ran
$LN10@Verify_ran:

; 200  :         _STL_VERIFY(_First._Ptr <= _Last._Ptr, "vector iterator range transposed");

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN13@Verify_ran
	jmp	SHORT $LN8@Verify_ran
$LN13@Verify_ran:
	mov	esi, esp
	push	OFFSET ??_C@_0CB@LIAHLBAO@vector?5iterator?5range?5transpose@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	200					; 000000c8H
	push	OFFSET ??_C@_0GB@NEMOGBCE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN20@Verify_ran
	int	3
$LN20@Verify_ran:
	mov	esi, esp
	push	0
	push	200					; 000000c8H
	push	OFFSET ??_C@_1MC@BDGGHEJF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1EG@ODKBEHFN@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN13@Verify_ran
$LN8@Verify_ran:
	xor	eax, eax
	jne	SHORT $LN10@Verify_ran

; 201  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Verify_range@std@@YAXABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@1@0@Z ENDP ; std::_Verify_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 42   :         this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 43   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Entity *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$allocator@PAVEntity@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$allocator@PAVEntity@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1387 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1388 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$allocator@PAVEntity@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVEntity@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVEntity@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1383 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1384 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVEntity@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Entity *> >::_Vector_val<std::_Simple_types<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEABV?$allocator@PAVEntity@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEABV?$allocator@PAVEntity@@@2@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Getal, COMDAT
; _this$ = ecx

; 2247 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2248 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QBEABV?$allocator@PAVEntity@@@2@XZ ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first

; 2249 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEABV?$allocator@PAVEntity@@@2@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Getal, COMDAT
; _this$ = ecx

; 2243 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2244 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVEntity@@@2@XZ ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Get_first

; 2245 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 2228 :     _CONSTEXPR20 void _Orphan_range(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2229 :         // orphan iterators within specified (inclusive) range
; 2230 : #if _HAS_CXX20
; 2231 :         if (_STD is_constant_evaluated()) {
; 2232 :             _Orphan_range_unlocked(_First, _Last);
; 2233 :         } else
; 2234 : #endif // _HAS_CXX20
; 2235 :         {
; 2236 :             _Orphan_range_locked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_locked

; 2237 :         }
; 2238 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z
_TEXT	SEGMENT
__Lock$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 2223 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2224 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2225 :         _Orphan_range_unlocked(_First, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range_unlocked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_unlocked

; 2226 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN7@Orphan_ran:
	DD	1
	DD	$LN6@Orphan_ran
$LN6@Orphan_ran:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN4@Orphan_ran
$LN4@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z
_TEXT	SEGMENT
__Temp$1 = -44						; size = 4
__Pnextptr$2 = -32					; size = 4
__Pnext$ = -20						; size = 4
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 2209 :     _CONSTEXPR20 void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2210 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 2211 :         while (*_Pnext) {

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Orphan_ran

; 2212 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Pnextptr$2[ebp], edx

; 2213 :             const auto _Temp     = *_Pnext;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$1[ebp], ecx

; 2214 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

	mov	eax, DWORD PTR __Pnextptr$2[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jb	SHORT $LN6@Orphan_ran
	mov	eax, DWORD PTR __Last$[ebp]
	cmp	eax, DWORD PTR __Pnextptr$2[ebp]
	jae	SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 2215 :                 _Pnext = &_Temp->_Mynextiter;

	mov	eax, DWORD PTR __Temp$1[ebp]
	add	eax, 4
	mov	DWORD PTR __Pnext$[ebp], eax

; 2216 :             } else { // orphan the iterator

	jmp	SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 2217 :                 _Temp->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Temp$1[ebp]
	mov	DWORD PTR [eax], 0

; 2218 :                 *_Pnext         = _Temp->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR __Temp$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN5@Orphan_ran:

; 2219 :             }
; 2220 :         }

	jmp	SHORT $LN2@Orphan_ran
$LN1@Orphan_ran:

; 2221 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range_unlocked@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEXPAPAVEntity@@0@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Xlength@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@CAXXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Xlength, COMDAT

; 2200 :     [[noreturn]] static void _Xlength() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2201 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 2202 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlength@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@CAXXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -80						; size = 4
__Mylast$ = -68						; size = 4
__Myfirst$ = -56					; size = 4
__My_data$ = -44					; size = 4
__Al$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy, COMDAT
; _this$ = ecx

; 2098 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2099 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2100 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2101 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2102 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2103 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2104 : 
; 2105 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2106 : 
; 2107 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy

; 2108 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Destroy_range<std::allocator<Entity *> >
	add	esp, 12					; 0000000cH

; 2109 :             _ASAN_VECTOR_REMOVE;
; 2110 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@PAVEntity@@@std@@QAEXQAPAVEntity@@I@Z ; std::allocator<Entity *>::deallocate

; 2111 : 
; 2112 :             _Myfirst = nullptr;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 2113 :             _Mylast  = nullptr;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 2114 :             _Myend   = nullptr;

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@Tidy:

; 2115 :         }
; 2116 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Change_array@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXQAPAVEntity@@II@Z
_TEXT	SEGMENT
__Myend$ = -68						; size = 4
__Mylast$ = -56						; size = 4
__Myfirst$ = -44					; size = 4
__My_data$ = -32					; size = 4
__Al$ = -20						; size = 4
_this$ = -8						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXQAPAVEntity@@II@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Change_array, COMDAT
; _this$ = ecx

; 2076 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2077 :         // orphan all iterators, discard old array, acquire new array
; 2078 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2079 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2080 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2081 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2082 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2083 : 
; 2084 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2085 : 
; 2086 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Change_arr

; 2087 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAVEntity@@@std@@@std@@YAXPAPAVEntity@@QAPAV1@AAV?$allocator@PAVEntity@@@0@@Z ; std::_Destroy_range<std::allocator<Entity *> >
	add	esp, 12					; 0000000cH

; 2088 :             _ASAN_VECTOR_REMOVE;
; 2089 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@PAVEntity@@@std@@QAEXQAPAVEntity@@I@Z ; std::allocator<Entity *>::deallocate
$LN2@Change_arr:

; 2090 :         }
; 2091 : 
; 2092 :         _Myfirst = _Newvec;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2093 :         _Mylast  = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], edx

; 2094 :         _Myend   = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], edx

; 2095 :         _ASAN_VECTOR_CREATE;
; 2096 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXQAPAVEntity@@II@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -44					; size = 4
__Max$ = -32						; size = 4
__Oldcapacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEII@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2024 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2025 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 2026 :         const size_type _Oldcapacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::capacity
	mov	DWORD PTR __Oldcapacity$[ebp], eax

; 2027 :         const auto _Max              = max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ; std::vector<Entity *,std::allocator<Entity *> >::max_size
	mov	DWORD PTR __Max$[ebp], eax

; 2028 : 
; 2029 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR __Max$[ebp]
	sub	ecx, eax
	cmp	DWORD PTR __Oldcapacity$[ebp], ecx
	jbe	SHORT $LN2@Calculate_

; 2030 :             return _Max; // geometric growth would overflow

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2031 :         }
; 2032 : 
; 2033 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	mov	eax, DWORD PTR __Oldcapacity$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Oldcapacity$[ebp]
	mov	DWORD PTR __Geometric$[ebp], eax

; 2034 : 
; 2035 :         if (_Geometric < _Newsize) {

	mov	eax, DWORD PTR __Geometric$[ebp]
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@Calculate_

; 2036 :             return _Newsize; // geometric growth would be insufficient

	mov	eax, DWORD PTR __Newsize$[ebp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2037 :         }
; 2038 : 
; 2039 :         return _Geometric; // geometric growth is sufficient

	mov	eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 2040 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEII@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::capacity, COMDAT
; _this$ = ecx

; 1940 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1941 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1942 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1943 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::max_size, COMDAT
; _this$ = ecx

; 1935 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1936 :         return (_STD min)(

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@ABEABV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Entity *> >::max_size
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1937 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1938 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QBEIXZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Unchecked_end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked_end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1917 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_end() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1918 :         return _Mypair._Myval2._Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 1919 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked_end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked_begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1909 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_begin() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1910 :         return _Mypair._Myval2._Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1911 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked_begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::end, COMDAT
; _this$ = ecx

; 1867 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1868 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1869 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<Entity *> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1870 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::begin, COMDAT
; _this$ = ecx

; 1857 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1858 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 1859 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	call	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<Entity *> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@QAE@PAPAVEntity@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1860 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z PROC ; std::vector<Entity *,std::allocator<Entity *> >::push_back, COMDAT
; _this$ = ecx

; 939  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 940  :         // insert by moving into element at end, provide strong guarantee
; 941  :         _Emplace_one_at_back(_STD move(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Emplace_one_at_back@PAVEntity@@@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAPAVEntity@@$$QAPAV2@@Z ; std::vector<Entity *,std::allocator<Entity *> >::_Emplace_one_at_back<Entity *>

; 942  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z ENDP ; std::vector<Entity *,std::allocator<Entity *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -240						; size = 4
_$S14$ = -33						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 830  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEXXZ ; std::vector<Entity *,std::allocator<Entity *> >::_Tidy

; 831  : #if _ITERATOR_DEBUG_LEVEL != 0
; 832  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S14$[ebp]
	call	??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>
	lea	eax, DWORD PTR _$S14$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 833  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 834  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 835  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@vector:
	DD	1
	DD	$LN4@vector
$LN4@vector:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN3@vector
$LN3@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	52					; 00000034H
	DB	0
??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ PROC ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >, COMDAT
; _this$ = ecx

; 673  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVEntity@@@std@@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1>::_Compressed_pair<std::allocator<Entity *>,std::_Vector_val<std::_Simple_types<Entity *> >,1><>

; 674  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@AAEAAV?$allocator@PAVEntity@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0PAVEntity@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVEntity@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Entity *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 675  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ENDP ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<Entity *> >::max_size, COMDAT

; 693  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 694  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 1073741823				; 3fffffffH

; 695  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@PAVEntity@@@std@@@std@@SAIABV?$allocator@PAVEntity@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Entity *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z PROC ; std::allocator<Entity *>::allocate, COMDAT
; _this$ = ecx

; 832  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 833  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 834  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$03@std@@YAII@Z	; std::_Get_size_of_n<4>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 835  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVEntity@@@std@@QAEPAPAVEntity@@I@Z ENDP ; std::allocator<Entity *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVEntity@@@std@@QAEXQAPAVEntity@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVEntity@@@std@@QAEXQAPAVEntity@@I@Z PROC ; std::allocator<Entity *>::deallocate, COMDAT
; _this$ = ecx

; 826  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
$LN4@deallocate:

; 827  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN7@deallocate
$LN10@deallocate:
	jmp	SHORT $LN2@deallocate
$LN7@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@deallocate
$LN2@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 828  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 829  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 830  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVEntity@@@std@@QAEXQAPAVEntity@@I@Z ENDP ; std::allocator<Entity *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$allocator@PAVEntity@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@PAVEntity@@@std@@QAE@XZ PROC		; std::allocator<Entity *>::allocator<Entity *>, COMDAT
; _this$ = ecx

; 818  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVEntity@@@std@@QAE@XZ ENDP		; std::allocator<Entity *>::allocator<Entity *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ?size@?$initializer_list@VEnemy@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$initializer_list@VEnemy@@@std@@QBEIXZ PROC	; std::initializer_list<Enemy>::size, COMDAT
; _this$ = ecx

; 45   :     _NODISCARD constexpr size_t size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx

; 47   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$initializer_list@VEnemy@@@std@@QBEIXZ ENDP	; std::initializer_list<Enemy>::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ?end@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?end@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ PROC ; std::initializer_list<Enemy>::end, COMDAT
; _this$ = ecx

; 41   :     _NODISCARD constexpr const _Elem* end() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4

; 42   :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 43   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?end@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ ENDP ; std::initializer_list<Enemy>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ?begin@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?begin@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ PROC ; std::initializer_list<Enemy>::begin, COMDAT
; _this$ = ecx

; 37   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4

; 38   :         return _First;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 39   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?begin@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ ENDP ; std::initializer_list<Enemy>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ??0?$initializer_list@VEnemy@@@std@@QAE@PBVEnemy@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@VEnemy@@@std@@QAE@PBVEnemy@@0@Z PROC ; std::initializer_list<Enemy>::initializer_list<Enemy>, COMDAT
; _this$ = ecx

; 35   :         : _First(_First_arg), _Last(_Last_arg) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$initializer_list@VEnemy@@@std@@QAE@PBVEnemy@@0@Z ENDP ; std::initializer_list<Enemy>::initializer_list<Enemy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z PROC ; std::vector<Enemy,std::allocator<Enemy> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Enemy,std::allocator<Enemy> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QBEABV?$allocator@VEnemy@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QBEABV?$allocator@VEnemy@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1387 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1388 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QBEABV?$allocator@VEnemy@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAEAAV?$allocator@VEnemy@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAEAAV?$allocator@VEnemy@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1383 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1384 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAEAAV?$allocator@VEnemy@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Enemy> >::_Vector_val<std::_Simple_types<Enemy> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Enemy> >::_Vector_val<std::_Simple_types<Enemy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@ABEABV?$allocator@VEnemy@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@ABEABV?$allocator@VEnemy@@@2@XZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Getal, COMDAT
; _this$ = ecx

; 2247 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2248 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QBEABV?$allocator@VEnemy@@@2@XZ ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first

; 2249 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@ABEABV?$allocator@VEnemy@@@2@XZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Getal, COMDAT
; _this$ = ecx

; 2243 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2244 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAEAAV?$allocator@VEnemy@@@2@XZ ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Get_first

; 2245 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Xlength@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@CAXXZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Xlength, COMDAT

; 2200 :     [[noreturn]] static void _Xlength() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2201 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 2202 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlength@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@CAXXZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -80						; size = 4
__Mylast$ = -68						; size = 4
__Myfirst$ = -56					; size = 4
__My_data$ = -44					; size = 4
__Al$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Tidy, COMDAT
; _this$ = ecx

; 2098 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2099 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2100 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2101 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2102 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2103 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2104 : 
; 2105 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2106 : 
; 2107 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy

; 2108 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@VEnemy@@@std@@@std@@YAXPAVEnemy@@QAV1@AAV?$allocator@VEnemy@@@0@@Z ; std::_Destroy_range<std::allocator<Enemy> >
	add	esp, 12					; 0000000cH

; 2109 :             _ASAN_VECTOR_REMOVE;
; 2110 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@VEnemy@@@std@@QAEXQAVEnemy@@I@Z ; std::allocator<Enemy>::deallocate

; 2111 : 
; 2112 :             _Myfirst = nullptr;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 2113 :             _Mylast  = nullptr;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 2114 :             _Myend   = nullptr;

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@Tidy:

; 2115 :         }
; 2116 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 2058 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2059 :         // allocate array with _Newcapacity elements
; 2060 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2061 :         auto& _My_data    = _Mypair._Myval2;
; 2062 :         pointer& _Myfirst = _My_data._Myfirst;
; 2063 :         pointer& _Mylast  = _My_data._Mylast;
; 2064 :         pointer& _Myend   = _My_data._Myend;
; 2065 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2066 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2067 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2068 : 
; 2069 :         if (_Newcapacity > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QBEIXZ ; std::vector<Enemy,std::allocator<Enemy> >::max_size
	cmp	DWORD PTR __Newcapacity$[ebp], eax
	jbe	SHORT $LN2@Buy_nonzer

; 2070 :             _Xlength();

	call	?_Xlength@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@CAXXZ ; std::vector<Enemy,std::allocator<Enemy> >::_Xlength
$LN2@Buy_nonzer:

; 2071 :         }
; 2072 : 
; 2073 :         _Buy_raw(_Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy_raw@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_raw
$LN3@Buy_nonzer:

; 2074 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy_nonzero@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Buy_raw@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -68						; size = 4
__Myend$ = -56						; size = 4
__Mylast$ = -44						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_raw, COMDAT
; _this$ = ecx

; 2042 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2043 :         // allocate array with _Newcapacity elements
; 2044 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2045 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2046 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2047 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2048 : 
; 2049 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2050 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 2051 : 
; 2052 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
	mov	ecx, eax
	call	?allocate@?$allocator@VEnemy@@@std@@QAEPAVEnemy@@I@Z ; std::allocator<Enemy>::allocate
	mov	DWORD PTR __Newvec$[ebp], eax

; 2053 :         _Myfirst           = _Newvec;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2054 :         _Mylast            = _Newvec;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2055 :         _Myend             = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[ebp], 48
	add	eax, DWORD PTR __Newvec$[ebp]
	mov	ecx, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [ecx], eax

; 2056 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy_raw@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI@Z ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?max_size@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
?max_size@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QBEIXZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::max_size, COMDAT
; _this$ = ecx

; 1935 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1936 :         return (_STD min)(

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@ABEABV?$allocator@VEnemy@@@2@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAIABV?$allocator@VEnemy@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Enemy> >::max_size
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1937 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1938 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QBEIXZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Unchecked_end@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked_end@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1917 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_end() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1918 :         return _Mypair._Myval2._Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 1919 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked_end@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked_begin@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1909 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_begin() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1910 :         return _Mypair._Myval2._Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1911 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked_begin@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??1?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -240						; size = 4
_$S15$ = -33						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ PROC ; std::vector<Enemy,std::allocator<Enemy> >::~vector<Enemy,std::allocator<Enemy> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 830  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXXZ ; std::vector<Enemy,std::allocator<Enemy> >::_Tidy

; 831  : #if _ITERATOR_DEBUG_LEVEL != 0
; 832  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEAAV?$allocator@VEnemy@@@2@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S15$[ebp]
	call	??$?0VEnemy@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VEnemy@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Enemy>
	lea	eax, DWORD PTR _$S15$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 833  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 834  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 835  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@vector:
	DD	1
	DD	$LN4@vector
$LN4@vector:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN3@vector
$LN3@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	53					; 00000035H
	DB	0
??1?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ENDP ; std::vector<Enemy,std::allocator<Enemy> >::~vector<Enemy,std::allocator<Enemy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??0?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@V?$initializer_list@VEnemy@@@1@ABV?$allocator@VEnemy@@@1@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
$T3 = -209						; size = 1
_this$ = -8						; size = 4
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@V?$initializer_list@VEnemy@@@1@ABV?$allocator@VEnemy@@@1@@Z PROC ; std::vector<Enemy,std::allocator<Enemy> >::vector<Enemy,std::allocator<Enemy> >, COMDAT
; _this$ = ecx

; 720  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0ABV?$allocator@VEnemy@@@std@@$$V@?$_Compressed_pair@V?$allocator@VEnemy@@@std@@V?$_Vector_val@U?$_Simple_types@VEnemy@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VEnemy@@@1@@Z ; std::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1>::_Compressed_pair<std::allocator<Enemy>,std::_Vector_val<std::_Simple_types<Enemy> >,1><std::allocator<Enemy> const &>

; 721  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());

	lea	ecx, DWORD PTR __Ilist$[ebp]
	call	?end@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ ; std::initializer_list<Enemy>::end
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR __Ilist$[ebp]
	call	?begin@?$initializer_list@VEnemy@@@std@@QBEPBVEnemy@@XZ ; std::initializer_list<Enemy>::begin
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Ilist$[ebp]
	call	?size@?$initializer_list@VEnemy@@@std@@QBEIXZ ; std::initializer_list<Enemy>::size
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct_n@PBVEnemy@@PBV1@@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@AAEXI$$QAPBVEnemy@@0@Z ; std::vector<Enemy,std::allocator<Enemy> >::_Construct_n<Enemy const *,Enemy const *>

; 722  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@V?$initializer_list@VEnemy@@@1@ABV?$allocator@VEnemy@@@1@@Z ENDP ; std::vector<Enemy,std::allocator<Enemy> >::vector<Enemy,std::allocator<Enemy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAIABV?$allocator@VEnemy@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAIABV?$allocator@VEnemy@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<Enemy> >::max_size, COMDAT

; 693  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 694  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 89478485				; 05555555H

; 695  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@VEnemy@@@std@@@std@@SAIABV?$allocator@VEnemy@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Enemy> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?allocate@?$allocator@VEnemy@@@std@@QAEPAVEnemy@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VEnemy@@@std@@QAEPAVEnemy@@I@Z PROC ; std::allocator<Enemy>::allocate, COMDAT
; _this$ = ecx

; 832  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 833  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 834  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$0DA@@std@@YAII@Z	; std::_Get_size_of_n<48>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 835  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VEnemy@@@std@@QAEPAVEnemy@@I@Z ENDP ; std::allocator<Enemy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?deallocate@?$allocator@VEnemy@@@std@@QAEXQAVEnemy@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VEnemy@@@std@@QAEXQAVEnemy@@I@Z PROC ; std::allocator<Enemy>::deallocate, COMDAT
; _this$ = ecx

; 826  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
$LN4@deallocate:

; 827  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN7@deallocate
$LN10@deallocate:
	jmp	SHORT $LN2@deallocate
$LN7@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@deallocate
$LN2@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 828  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 829  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	eax, DWORD PTR __Count$[ebp], 48
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 830  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VEnemy@@@std@@QAEXQAVEnemy@@I@Z ENDP ; std::allocator<Enemy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$allocator@VEnemy@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@VEnemy@@@std@@QAE@XZ PROC		; std::allocator<Enemy>::allocator<Enemy>, COMDAT
; _this$ = ecx

; 818  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VEnemy@@@std@@QAE@XZ ENDP		; std::allocator<Enemy>::allocator<Enemy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ?size@?$initializer_list@VPlayer@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$initializer_list@VPlayer@@@std@@QBEIXZ PROC	; std::initializer_list<Player>::size, COMDAT
; _this$ = ecx

; 45   :     _NODISCARD constexpr size_t size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4

; 46   :         return static_cast<size_t>(_Last - _First);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx

; 47   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$initializer_list@VPlayer@@@std@@QBEIXZ ENDP	; std::initializer_list<Player>::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ?end@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?end@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ PROC ; std::initializer_list<Player>::end, COMDAT
; _this$ = ecx

; 41   :     _NODISCARD constexpr const _Elem* end() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4

; 42   :         return _Last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 43   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?end@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ ENDP ; std::initializer_list<Player>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ?begin@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?begin@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ PROC ; std::initializer_list<Player>::begin, COMDAT
; _this$ = ecx

; 37   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4

; 38   :         return _First;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 39   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?begin@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ ENDP ; std::initializer_list<Player>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\initializer_list
;	COMDAT ??0?$initializer_list@VPlayer@@@std@@QAE@PBVPlayer@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@VPlayer@@@std@@QAE@PBVPlayer@@0@Z PROC ; std::initializer_list<Player>::initializer_list<Player>, COMDAT
; _this$ = ecx

; 35   :         : _First(_First_arg), _Last(_Last_arg) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __6EE2661F_initializer_list
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$initializer_list@VPlayer@@@std@@QAE@PBVPlayer@@0@Z ENDP ; std::initializer_list<Player>::initializer_list<Player>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z PROC ; std::vector<Player,std::allocator<Player> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Player,std::allocator<Player> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QBEABV?$allocator@VPlayer@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QBEABV?$allocator@VPlayer@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1387 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1388 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QBEABV?$allocator@VPlayer@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAEAAV?$allocator@VPlayer@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAEAAV?$allocator@VPlayer@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1383 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1384 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAEAAV?$allocator@VPlayer@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Player> >::_Vector_val<std::_Simple_types<Player> >, COMDAT
; _this$ = ecx

; 390  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Player> >::_Vector_val<std::_Simple_types<Player> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@ABEABV?$allocator@VPlayer@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@ABEABV?$allocator@VPlayer@@@2@XZ PROC ; std::vector<Player,std::allocator<Player> >::_Getal, COMDAT
; _this$ = ecx

; 2247 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2248 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QBEABV?$allocator@VPlayer@@@2@XZ ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first

; 2249 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@ABEABV?$allocator@VPlayer@@@2@XZ ENDP ; std::vector<Player,std::allocator<Player> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ PROC ; std::vector<Player,std::allocator<Player> >::_Getal, COMDAT
; _this$ = ecx

; 2243 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2244 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAEAAV?$allocator@VPlayer@@@2@XZ ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Get_first

; 2245 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ ENDP ; std::vector<Player,std::allocator<Player> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Xlength@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@CAXXZ PROC ; std::vector<Player,std::allocator<Player> >::_Xlength, COMDAT

; 2200 :     [[noreturn]] static void _Xlength() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2201 :         _Xlength_error("vector too long");

	push	OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlength:

; 2202 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlength@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@CAXXZ ENDP ; std::vector<Player,std::allocator<Player> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -80						; size = 4
__Mylast$ = -68						; size = 4
__Myfirst$ = -56					; size = 4
__My_data$ = -44					; size = 4
__Al$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ PROC ; std::vector<Player,std::allocator<Player> >::_Tidy, COMDAT
; _this$ = ecx

; 2098 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2099 :         auto& _Al         = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ ; std::vector<Player,std::allocator<Player> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2100 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2101 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2102 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2103 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2104 : 
; 2105 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2106 : 
; 2107 :         if (_Myfirst) { // destroy and deallocate old array

	mov	eax, DWORD PTR __Myfirst$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Tidy

; 2108 :             _Destroy_range(_Myfirst, _Mylast, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mylast$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Destroy_range@V?$allocator@VPlayer@@@std@@@std@@YAXPAVPlayer@@QAV1@AAV?$allocator@VPlayer@@@0@@Z ; std::_Destroy_range<std::allocator<Player> >
	add	esp, 12					; 0000000cH

; 2109 :             _ASAN_VECTOR_REMOVE;
; 2110 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	ecx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR __Myfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@VPlayer@@@std@@QAEXQAVPlayer@@I@Z ; std::allocator<Player>::deallocate

; 2111 : 
; 2112 :             _Myfirst = nullptr;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	DWORD PTR [eax], 0

; 2113 :             _Mylast  = nullptr;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	DWORD PTR [eax], 0

; 2114 :             _Myend   = nullptr;

	mov	eax, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [eax], 0
$LN3@Tidy:

; 2115 :         }
; 2116 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ ENDP ; std::vector<Player,std::allocator<Player> >::_Tidy
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z PROC ; std::vector<Player,std::allocator<Player> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 2058 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2059 :         // allocate array with _Newcapacity elements
; 2060 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2061 :         auto& _My_data    = _Mypair._Myval2;
; 2062 :         pointer& _Myfirst = _My_data._Myfirst;
; 2063 :         pointer& _Mylast  = _My_data._Mylast;
; 2064 :         pointer& _Myend   = _My_data._Myend;
; 2065 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2066 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2067 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2068 : 
; 2069 :         if (_Newcapacity > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QBEIXZ ; std::vector<Player,std::allocator<Player> >::max_size
	cmp	DWORD PTR __Newcapacity$[ebp], eax
	jbe	SHORT $LN2@Buy_nonzer

; 2070 :             _Xlength();

	call	?_Xlength@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@CAXXZ ; std::vector<Player,std::allocator<Player> >::_Xlength
$LN2@Buy_nonzer:

; 2071 :         }
; 2072 : 
; 2073 :         _Buy_raw(_Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy_raw@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z ; std::vector<Player,std::allocator<Player> >::_Buy_raw
$LN3@Buy_nonzer:

; 2074 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy_nonzero@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z ENDP ; std::vector<Player,std::allocator<Player> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Buy_raw@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Newvec$ = -68						; size = 4
__Myend$ = -56						; size = 4
__Mylast$ = -44						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z PROC ; std::vector<Player,std::allocator<Player> >::_Buy_raw, COMDAT
; _this$ = ecx

; 2042 :     _CONSTEXPR20 void _Buy_raw(const size_type _Newcapacity) {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 2043 :         // allocate array with _Newcapacity elements
; 2044 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2045 :         pointer& _Myfirst = _My_data._Myfirst;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	mov	DWORD PTR __Myfirst$[ebp], eax

; 2046 :         pointer& _Mylast  = _My_data._Mylast;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 8
	mov	DWORD PTR __Mylast$[ebp], eax

; 2047 :         pointer& _Myend   = _My_data._Myend;

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Myend$[ebp], eax

; 2048 : 
; 2049 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2050 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 2051 : 
; 2052 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ ; std::vector<Player,std::allocator<Player> >::_Getal
	mov	ecx, eax
	call	?allocate@?$allocator@VPlayer@@@std@@QAEPAVPlayer@@I@Z ; std::allocator<Player>::allocate
	mov	DWORD PTR __Newvec$[ebp], eax

; 2053 :         _Myfirst           = _Newvec;

	mov	eax, DWORD PTR __Myfirst$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2054 :         _Mylast            = _Newvec;

	mov	eax, DWORD PTR __Mylast$[ebp]
	mov	ecx, DWORD PTR __Newvec$[ebp]
	mov	DWORD PTR [eax], ecx

; 2055 :         _Myend             = _Newvec + _Newcapacity;

	imul	eax, DWORD PTR __Newcapacity$[ebp], 44
	add	eax, DWORD PTR __Newvec$[ebp]
	mov	ecx, DWORD PTR __Myend$[ebp]
	mov	DWORD PTR [ecx], eax

; 2056 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy_raw@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI@Z ENDP ; std::vector<Player,std::allocator<Player> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?max_size@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
$T2 = -212						; size = 4
_this$ = -8						; size = 4
?max_size@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QBEIXZ PROC ; std::vector<Player,std::allocator<Player> >::max_size, COMDAT
; _this$ = ecx

; 1935 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1936 :         return (_STD min)(

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@ABEABV?$allocator@VPlayer@@@2@XZ ; std::vector<Player,std::allocator<Player> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAIABV?$allocator@VPlayer@@@2@@Z ; std::_Default_allocator_traits<std::allocator<Player> >::max_size
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 1937 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1938 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QBEIXZ ENDP ; std::vector<Player,std::allocator<Player> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Unchecked_end@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked_end@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ PROC ; std::vector<Player,std::allocator<Player> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1917 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_end() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1918 :         return _Mypair._Myval2._Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 1919 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked_end@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ENDP ; std::vector<Player,std::allocator<Player> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked_begin@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ PROC ; std::vector<Player,std::allocator<Player> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1909 :     _NODISCARD _CONSTEXPR20 pointer _Unchecked_begin() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 1910 :         return _Mypair._Myval2._Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 1911 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked_begin@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ENDP ; std::vector<Player,std::allocator<Player> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??1?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -240						; size = 4
_$S16$ = -33						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ PROC ; std::vector<Player,std::allocator<Player> >::~vector<Player,std::allocator<Player> >, COMDAT
; _this$ = ecx

; 829  :     _CONSTEXPR20 ~vector() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4

; 830  :         _Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXXZ ; std::vector<Player,std::allocator<Player> >::_Tidy

; 831  : #if _ITERATOR_DEBUG_LEVEL != 0
; 832  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEAAV?$allocator@VPlayer@@@2@XZ ; std::vector<Player,std::allocator<Player> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S16$[ebp]
	call	??$?0VPlayer@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VPlayer@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Player>
	lea	eax, DWORD PTR _$S16$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 833  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR __Alproxy$[ebp]
	push	edx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 834  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 835  :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@vector
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@vector:
	DD	1
	DD	$LN4@vector
$LN4@vector:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN3@vector
$LN3@vector:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	0
??1?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ENDP ; std::vector<Player,std::allocator<Player> >::~vector<Player,std::allocator<Player> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vector
;	COMDAT ??0?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@V?$initializer_list@VPlayer@@@1@ABV?$allocator@VPlayer@@@1@@Z
_TEXT	SEGMENT
$T1 = -236						; size = 4
$T2 = -224						; size = 4
$T3 = -209						; size = 1
_this$ = -8						; size = 4
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@V?$initializer_list@VPlayer@@@1@ABV?$allocator@VPlayer@@@1@@Z PROC ; std::vector<Player,std::allocator<Player> >::vector<Player,std::allocator<Player> >, COMDAT
; _this$ = ecx

; 720  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __305A5C32_vector
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0ABV?$allocator@VPlayer@@@std@@$$V@?$_Compressed_pair@V?$allocator@VPlayer@@@std@@V?$_Vector_val@U?$_Simple_types@VPlayer@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@VPlayer@@@1@@Z ; std::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1>::_Compressed_pair<std::allocator<Player>,std::_Vector_val<std::_Simple_types<Player> >,1><std::allocator<Player> const &>

; 721  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());

	lea	ecx, DWORD PTR __Ilist$[ebp]
	call	?end@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ ; std::initializer_list<Player>::end
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR __Ilist$[ebp]
	call	?begin@?$initializer_list@VPlayer@@@std@@QBEPBVPlayer@@XZ ; std::initializer_list<Player>::begin
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Ilist$[ebp]
	call	?size@?$initializer_list@VPlayer@@@std@@QBEIXZ ; std::initializer_list<Player>::size
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct_n@PBVPlayer@@PBV1@@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@AAEXI$$QAPBVPlayer@@0@Z ; std::vector<Player,std::allocator<Player> >::_Construct_n<Player const *,Player const *>

; 722  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@V?$initializer_list@VPlayer@@@1@ABV?$allocator@VPlayer@@@1@@Z ENDP ; std::vector<Player,std::allocator<Player> >::vector<Player,std::allocator<Player> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAIABV?$allocator@VPlayer@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAIABV?$allocator@VPlayer@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<Player> >::max_size, COMDAT

; 693  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 694  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	eax, 97612893				; 05d1745dH

; 695  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@VPlayer@@@std@@@std@@SAIABV?$allocator@VPlayer@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Player> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?allocate@?$allocator@VPlayer@@@std@@QAEPAVPlayer@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VPlayer@@@std@@QAEPAVPlayer@@I@Z PROC ; std::allocator<Player>::allocate, COMDAT
; _this$ = ecx

; 832  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 833  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 834  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$0CM@@std@@YAII@Z	; std::_Get_size_of_n<44>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 835  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VPlayer@@@std@@QAEPAVPlayer@@I@Z ENDP ; std::allocator<Player>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?deallocate@?$allocator@VPlayer@@@std@@QAEXQAVPlayer@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@VPlayer@@@std@@QAEXQAVPlayer@@I@Z PROC ; std::allocator<Player>::deallocate, COMDAT
; _this$ = ecx

; 826  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
$LN4@deallocate:

; 827  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN7@deallocate
$LN10@deallocate:
	jmp	SHORT $LN2@deallocate
$LN7@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@deallocate
$LN2@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 828  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 829  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	eax, DWORD PTR __Count$[ebp], 44
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 830  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VPlayer@@@std@@QAEXQAVPlayer@@I@Z ENDP ; std::allocator<Player>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$allocator@VPlayer@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@VPlayer@@@std@@QAE@XZ PROC		; std::allocator<Player>::allocator<Player>, COMDAT
; _this$ = ecx

; 818  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VPlayer@@@std@@QAE@XZ ENDP		; std::allocator<Player>::allocator<Player>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv662 = -2084						; size = 4
tv249 = -2084						; size = 4
tv220 = -2084						; size = 4
tv188 = -2084						; size = 4
tv95 = -2084						; size = 4
tv85 = -2084						; size = 4
tv70 = -2084						; size = 4
$T2 = -2076						; size = 176
$T3 = -1892						; size = 192
$T4 = -1692						; size = 4
$T5 = -1680						; size = 4
$T6 = -1668						; size = 4
$T7 = -1656						; size = 4
$T8 = -1644						; size = 4
$T9 = -1632						; size = 8
$T10 = -1616						; size = 28
$T11 = -1580						; size = 28
$T12 = -1544						; size = 28
$T13 = -1508						; size = 28
$T14 = -1469						; size = 1
$T15 = -1460						; size = 8
$T16 = -1444						; size = 28
$T17 = -1408						; size = 28
$T18 = -1372						; size = 28
$T19 = -1336						; size = 28
$T20 = -1297						; size = 1
$T21 = -1288						; size = 28
$T22 = -1252						; size = 28
$T23 = -1216						; size = 44
$T24 = -1164						; size = 4
$T25 = -1152						; size = 4
$T26 = -1140						; size = 4
$T27 = -1128						; size = 28
$T28 = -1092						; size = 4
$T29 = -1080						; size = 4
$T30 = -1068						; size = 4
$T31 = -1056						; size = 4
$T32 = -1044						; size = 4
_enemy$33 = -456					; size = 4
_player$34 = -444					; size = 4
_entity$35 = -432					; size = 4
_<end>$L2$36 = -420					; size = 4
_<begin>$L2$37 = -408					; size = 4
_<range>$L2$38 = -396					; size = 4
_enemy$39 = -384					; size = 4
_<end>$L1$40 = -372					; size = 4
_<begin>$L1$41 = -360					; size = 4
_<range>$L1$42 = -348					; size = 4
_player$43 = -336					; size = 4
_<end>$L0$44 = -324					; size = 4
_<begin>$L0$45 = -312					; size = 4
_<range>$L0$46 = -300					; size = 4
_entities$ = -288					; size = 16
_enemies$ = -264					; size = 16
_players$ = -240					; size = 16
_player2Ref$ = -216					; size = 4
_player2$ = -204					; size = 44
_player$ = -152						; size = 12
_enemy5$ = -132						; size = 4
_enemy4$ = -120						; size = 4
_enemy3$ = -108						; size = 4
_enemy2$ = -96						; size = 4
_enemy$ = -84						; size = 4
_e5$ = -72						; size = 4
_e4$ = -60						; size = 4
_e3$ = -48						; size = 4
_e2$ = -36						; size = 4
_e$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$_main
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2072				; 00000818H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1508]
	mov	ecx, 374				; 00000176H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T4[ebp], 0
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 165  : 	// create an Entity pointer instance on the	heap. 
; 166  : 	Entity* e = new Entity();

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T32[ebp], eax
	cmp	DWORD PTR $T32[ebp], 0
	je	SHORT $LN15@main
	xor	eax, eax
	mov	ecx, DWORD PTR $T32[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T32[ebp]
	call	??0Entity@@QAE@XZ
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN16@main
$LN15@main:
	mov	DWORD PTR tv70[ebp], 0
$LN16@main:
	mov	edx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _e$[ebp], edx

; 167  : 
; 168  : 	// create a copy of the Entity pointer instance. This is a shallow copy. 
; 169  : 	// This just copies the pointer. The pointer points to the same memory address as the original pointer.
; 170  : 	Entity* e2 = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _e2$[ebp], eax

; 171  : 
; 172  : 	// create a copy of the Entity pointer instance. This is a deep copy. 
; 173  : 	// This creates a new instance of the Entity class and copies the values from the original pointer to the new pointer.
; 174  : 	Entity* e3 = new Entity(*e);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T31[ebp], eax
	cmp	DWORD PTR $T31[ebp], 0
	je	SHORT $LN17@main
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T31[ebp]
	call	??0Entity@@QAE@ABV0@@Z
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN18@main
$LN17@main:
	mov	DWORD PTR tv85[ebp], 0
$LN18@main:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _e3$[ebp], ecx

; 175  : 
; 176  : 	// move the Entity pointer instance to a new pointer. This is a shallow copy. 
; 177  : 	//This just copies the pointer. The pointer points to the same memory address as the original pointer.
; 178  : 	Entity* e4 = std::move(e);

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR _e4$[ebp], eax

; 179  : 
; 180  : 	// move the Entity pointer instance to a new pointer. This is a deep copy. 
; 181  : 	// This creates a new instance of the Entity class and copies the values from the original pointer to the new pointer.
; 182  : 	Entity* e5 = new Entity(std::move(*e3));

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T30[ebp], eax
	cmp	DWORD PTR $T30[ebp], 0
	je	SHORT $LN19@main
	mov	eax, DWORD PTR _e3$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T30[ebp]
	call	??0Entity@@QAE@ABV0@@Z
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN20@main
$LN19@main:
	mov	DWORD PTR tv95[ebp], 0
$LN20@main:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR _e5$[ebp], ecx

; 183  : 
; 184  : 	// how many pointers do i have?
; 185  : 	std::cout << "e:  " << e << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	push	OFFSET ??_C@_04FKFAIKFI@e?3?5?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 186  : 	std::cout << "e2: " << e2 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _e2$[ebp]
	push	eax
	push	OFFSET ??_C@_04IOFFIEBB@e2?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 187  : 	std::cout << "e3: " << e3 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _e3$[ebp]
	push	eax
	push	OFFSET ??_C@_04DGOJODHE@e3?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 188  : 	std::cout << "e4: " << e4 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _e4$[ebp]
	push	eax
	push	OFFSET ??_C@_04KLDONLMN@e4?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 189  : 	std::cout << "e5: " << e5 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _e5$[ebp]
	push	eax
	push	OFFSET ??_C@_04BDICLMKI@e5?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 190  : 	std::cout << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 191  : 
; 192  : 	// Create an Enemy pointer instance on the heap.
; 193  : 	Enemy* enemy = new Enemy("Enemy", 100, 10);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T28[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T28[ebp], 0
	je	SHORT $LN21@main
	push	OFFSET ??_C@_05IFKAJBFC@Enemy@
	lea	ecx, DWORD PTR $T27[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T4[ebp]
	or	eax, 1
	mov	DWORD PTR $T4[ebp], eax
	push	10					; 0000000aH
	push	100					; 00000064H
	lea	ecx, DWORD PTR $T27[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T28[ebp]
	call	??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; Enemy::Enemy
	mov	DWORD PTR tv188[ebp], eax
	jmp	SHORT $LN22@main
$LN21@main:
	mov	DWORD PTR tv188[ebp], 0
$LN22@main:
	mov	edx, DWORD PTR tv188[ebp]
	mov	DWORD PTR $T29[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR $T29[ebp]
	mov	DWORD PTR _enemy$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	and	ecx, 1
	je	SHORT $LN30@main
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T27[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN30@main:

; 194  : 	std::cout << "enemy:  " << enemy << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _enemy$[ebp]
	push	eax
	push	OFFSET ??_C@_08GBBKBKMM@enemy?3?5?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 195  : 	std::cout << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 196  : 
; 197  : 	// Create a copy of the Enemy pointer instance. This is a shallow copy.
; 198  : 	// This just copies the pointer. The pointer points to the same memory address as the original pointer.
; 199  : 	Enemy* enemy2 = enemy;

	mov	eax, DWORD PTR _enemy$[ebp]
	mov	DWORD PTR _enemy2$[ebp], eax

; 200  : 	std::cout << "enemy2: " << enemy2 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _enemy2$[ebp]
	push	eax
	push	OFFSET ??_C@_08LFBPBEIF@enemy2?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 201  : 	std::cout << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 202  : 
; 203  : 	// Create a copy of the Enemy pointer instance. This is a deep copy.
; 204  : 	// This creates a new instance of the Enemy class and copies the values from the original pointer to the new pointer.
; 205  : 	Enemy* enemy3 = new Enemy(*enemy);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T25[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN23@main
	mov	eax, DWORD PTR _enemy$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T25[ebp]
	call	??0Enemy@@QAE@ABV0@@Z			; Enemy::Enemy
	mov	DWORD PTR tv220[ebp], eax
	jmp	SHORT $LN24@main
$LN23@main:
	mov	DWORD PTR tv220[ebp], 0
$LN24@main:
	mov	ecx, DWORD PTR tv220[ebp]
	mov	DWORD PTR $T26[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T26[ebp]
	mov	DWORD PTR _enemy3$[ebp], edx

; 206  : 	std::cout << "enemy3: " << enemy3 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _enemy3$[ebp]
	push	eax
	push	OFFSET ??_C@_08NKDHDOA@enemy3?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 207  : 	std::cout << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 208  : 
; 209  : 	// move the Enemy pointer instance to a new pointer. This is a shallow copy.
; 210  : 	// This just copies the pointer. The pointer points to the same memory address as the original pointer.
; 211  : 	Enemy* enemy4 = std::move(enemy);

	mov	eax, DWORD PTR _enemy$[ebp]
	mov	DWORD PTR _enemy4$[ebp], eax

; 212  : 	std::cout << "enemy4: " << enemy4 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _enemy4$[ebp]
	push	eax
	push	OFFSET ??_C@_08JAHEELFJ@enemy4?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 213  : 	std::cout << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 214  : 
; 215  : 	// move the Enemy pointer instance to a new pointer. This is a deep copy.
; 216  : 	// This creates a new instance of the Enemy class and copies the values from the original pointer to the new pointer.
; 217  : 	Enemy* enemy5 = new Enemy(std::move(*enemy3));

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T24[ebp], eax
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN25@main
	mov	eax, DWORD PTR _enemy3$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T24[ebp]
	call	??0Enemy@@QAE@$$QAV0@@Z			; Enemy::Enemy
	mov	DWORD PTR tv249[ebp], eax
	jmp	SHORT $LN26@main
$LN25@main:
	mov	DWORD PTR tv249[ebp], 0
$LN26@main:
	mov	ecx, DWORD PTR tv249[ebp]
	mov	DWORD PTR _enemy5$[ebp], ecx

; 218  : 	std::cout << "enemy5: " << enemy5 << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _enemy5$[ebp]
	push	eax
	push	OFFSET ??_C@_08CIMICMDM@enemy5?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@PBX@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 219  : 	std::cout << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 220  : 
; 221  : 	// how many pointers do i have?
; 222  : 
; 223  : 	Entity player = Player("Player", 10); // create a Player instance on the stack and pass it to the Entity constructor

	push	OFFSET ??_C@_06NPAAKFED@Player@
	lea	ecx, DWORD PTR $T22[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	push	10					; 0000000aH
	lea	eax, DWORD PTR $T22[ebp]
	push	eax
	lea	ecx, DWORD PTR $T23[ebp]
	call	??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Player::Player
	mov	DWORD PTR tv662[ebp], eax
	mov	ecx, DWORD PTR tv662[ebp]
	push	ecx
	lea	ecx, DWORD PTR _player$[ebp]
	call	??0Entity@@QAE@ABV0@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T23[ebp]
	call	??1Player@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T22[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 224  : 	player.PrintName(); // call the PrintName() function from the Entity class due to object slicing.

	lea	ecx, DWORD PTR _player$[ebp]
	call	?PrintName@Entity@@UAEXXZ		; Entity::PrintName

; 225  : 	// print size in bytes of player
; 226  : 	std::cout << "Size of player: " << sizeof(player) << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	push	12					; 0000000cH
	push	OFFSET ??_C@_0BB@OGJJDCHI@Size?5of?5player?3?5@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 227  : 
; 228  : 	Player player2("Player2", 10); // create a Player instance on the stack

	push	OFFSET ??_C@_07CHKEEPO@Player2@
	lea	ecx, DWORD PTR $T21[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	10					; 0000000aH
	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	lea	ecx, DWORD PTR _player2$[ebp]
	call	??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Player::Player
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T21[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 229  : 	Entity& player2Ref = player2; // create a reference to the Player instance

	lea	eax, DWORD PTR _player2$[ebp]
	mov	DWORD PTR _player2Ref$[ebp], eax

; 230  : 	player2Ref.PrintName(); // call the PrintName() function from the Player class due to polymorphism.

	mov	eax, DWORD PTR _player2Ref$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _player2Ref$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	cmp	esi, esp
	call	__RTC_CheckEsp

; 231  : 	// print size in bytes of player2Ref
; 232  : 	std::cout << "Size of player2: " << sizeof(player2) << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	push	44					; 0000002cH
	push	OFFSET ??_C@_0BC@BPLJEKNH@Size?5of?5player2?3?5@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 233  : 
; 234  : 
; 235  : 	// create a vector of 4 players
; 236  : 	std::vector<Player> players = { Player("Player1", 10), Player("Player2", 10), Player("Player3", 10), Player("Player4", 10) };

	push	16					; 00000010H
	lea	ecx, DWORD PTR _players$[ebp]
	call	?__autoclassinit2@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEXI@Z
	push	OFFSET ??_C@_07CJFHBHDN@Player1@
	lea	ecx, DWORD PTR $T19[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	push	10					; 0000000aH
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Player::Player
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	push	OFFSET ??_C@_07CHKEEPO@Player2@
	lea	ecx, DWORD PTR $T18[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	push	10					; 0000000aH
	lea	ecx, DWORD PTR $T18[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp+44]
	call	??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Player::Player
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	push	OFFSET ??_C@_07BLGBHFLP@Player3@
	lea	ecx, DWORD PTR $T17[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	push	10					; 0000000aH
	lea	edx, DWORD PTR $T17[ebp]
	push	edx
	lea	ecx, DWORD PTR $T2[ebp+88]
	call	??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Player::Player
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	push	OFFSET ??_C@_07FECAODHI@Player4@
	lea	ecx, DWORD PTR $T16[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	push	10					; 0000000aH
	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp+132]
	call	??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Player::Player
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	lea	ecx, DWORD PTR $T20[ebp]
	call	??0?$allocator@VPlayer@@@std@@QAE@XZ	; std::allocator<Player>::allocator<Player>
	push	eax
	lea	ecx, DWORD PTR $T2[ebp+176]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR $T15[ebp]
	call	??0?$initializer_list@VPlayer@@@std@@QAE@PBVPlayer@@0@Z ; std::initializer_list<Player>::initializer_list<Player>
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _players$[ebp]
	call	??0?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@V?$initializer_list@VPlayer@@@1@ABV?$allocator@VPlayer@@@1@@Z ; std::vector<Player,std::allocator<Player> >::vector<Player,std::allocator<Player> >
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	push	OFFSET ??1Player@@UAE@XZ
	push	4
	push	44					; 0000002cH
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	lea	ecx, DWORD PTR $T16[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	lea	ecx, DWORD PTR $T17[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	lea	ecx, DWORD PTR $T18[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	lea	ecx, DWORD PTR $T19[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 237  : 	// create a vector of 4 enemies
; 238  : 	std::vector<Enemy> enemies = { Enemy("Enemy1", 10, 10), Enemy("Enemy2", 10, 10), Enemy("Enemy3", 10, 10), Enemy("Enemy4", 10, 10) };

	push	16					; 00000010H
	lea	ecx, DWORD PTR _enemies$[ebp]
	call	?__autoclassinit2@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEXI@Z
	push	OFFSET ??_C@_06EDLNJHPL@Enemy1@
	lea	ecx, DWORD PTR $T13[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	push	10					; 0000000aH
	push	10					; 0000000aH
	lea	eax, DWORD PTR $T13[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; Enemy::Enemy
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	push	OFFSET ??_C@_06GIJAMEDI@Enemy2@
	lea	ecx, DWORD PTR $T12[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	push	10					; 0000000aH
	push	10					; 0000000aH
	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T3[ebp+48]
	call	??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; Enemy::Enemy
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	push	OFFSET ??_C@_06HBILPFHJ@Enemy3@
	lea	ecx, DWORD PTR $T11[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	push	10					; 0000000aH
	push	10					; 0000000aH
	lea	edx, DWORD PTR $T11[ebp]
	push	edx
	lea	ecx, DWORD PTR $T3[ebp+96]
	call	??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; Enemy::Enemy
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	push	OFFSET ??_C@_06DOMKGDLO@Enemy4@
	lea	ecx, DWORD PTR $T10[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	push	10					; 0000000aH
	push	10					; 0000000aH
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp+144]
	call	??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ; Enemy::Enemy
	mov	BYTE PTR __$EHRec$[ebp+8], 37		; 00000025H
	lea	ecx, DWORD PTR $T14[ebp]
	call	??0?$allocator@VEnemy@@@std@@QAE@XZ	; std::allocator<Enemy>::allocator<Enemy>
	push	eax
	lea	ecx, DWORD PTR $T3[ebp+192]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T9[ebp]
	call	??0?$initializer_list@VEnemy@@@std@@QAE@PBVEnemy@@0@Z ; std::initializer_list<Enemy>::initializer_list<Enemy>
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	ecx, DWORD PTR _enemies$[ebp]
	call	??0?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@V?$initializer_list@VEnemy@@@1@ABV?$allocator@VEnemy@@@1@@Z ; std::vector<Enemy,std::allocator<Enemy> >::vector<Enemy,std::allocator<Enemy> >
	mov	BYTE PTR __$EHRec$[ebp+8], 39		; 00000027H
	push	OFFSET ??1Enemy@@UAE@XZ
	push	4
	push	48					; 00000030H
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 40		; 00000028H
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 41		; 00000029H
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 42		; 0000002aH
	lea	ecx, DWORD PTR $T12[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 43		; 0000002bH
	lea	ecx, DWORD PTR $T13[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 239  : 
; 240  : 	// create a data structure to hold both players and enemies
; 241  : 	std::vector<Entity*> entities;

	push	16					; 00000010H
	lea	ecx, DWORD PTR _entities$[ebp]
	call	?__autoclassinit2@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEXI@Z
	lea	ecx, DWORD PTR _entities$[ebp]
	call	??0?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::vector<Entity *,std::allocator<Entity *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 44		; 0000002cH

; 242  : 	// add players to the entities vector
; 243  : 	for (auto& player : players)

	lea	eax, DWORD PTR _players$[ebp]
	mov	DWORD PTR _<range>$L0$46[ebp], eax
	mov	ecx, DWORD PTR _<range>$L0$46[ebp]
	call	?_Unchecked_begin@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ; std::vector<Player,std::allocator<Player> >::_Unchecked_begin
	mov	DWORD PTR _<begin>$L0$45[ebp], eax
	mov	ecx, DWORD PTR _<range>$L0$46[ebp]
	call	?_Unchecked_end@?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAEPAVPlayer@@XZ ; std::vector<Player,std::allocator<Player> >::_Unchecked_end
	mov	DWORD PTR _<end>$L0$44[ebp], eax
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR _<begin>$L0$45[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR _<begin>$L0$45[ebp], eax
$LN4@main:
	mov	eax, DWORD PTR _<begin>$L0$45[ebp]
	cmp	eax, DWORD PTR _<end>$L0$44[ebp]
	je	SHORT $LN3@main
	mov	eax, DWORD PTR _<begin>$L0$45[ebp]
	mov	DWORD PTR _player$43[ebp], eax

; 244  : 	{
; 245  : 		entities.push_back(&player);

	mov	eax, DWORD PTR _player$43[ebp]
	mov	DWORD PTR $T8[ebp], eax
	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	lea	ecx, DWORD PTR _entities$[ebp]
	call	?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::push_back

; 246  : 	}

	jmp	SHORT $LN2@main
$LN3@main:

; 247  : 	// add enemies to the entities vector
; 248  : 	for (auto& enemy : enemies)

	lea	eax, DWORD PTR _enemies$[ebp]
	mov	DWORD PTR _<range>$L1$42[ebp], eax
	mov	ecx, DWORD PTR _<range>$L1$42[ebp]
	call	?_Unchecked_begin@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_begin
	mov	DWORD PTR _<begin>$L1$41[ebp], eax
	mov	ecx, DWORD PTR _<range>$L1$42[ebp]
	call	?_Unchecked_end@?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAEPAVEnemy@@XZ ; std::vector<Enemy,std::allocator<Enemy> >::_Unchecked_end
	mov	DWORD PTR _<end>$L1$40[ebp], eax
	jmp	SHORT $LN7@main
$LN5@main:
	mov	eax, DWORD PTR _<begin>$L1$41[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR _<begin>$L1$41[ebp], eax
$LN7@main:
	mov	eax, DWORD PTR _<begin>$L1$41[ebp]
	cmp	eax, DWORD PTR _<end>$L1$40[ebp]
	je	SHORT $LN6@main
	mov	eax, DWORD PTR _<begin>$L1$41[ebp]
	mov	DWORD PTR _enemy$39[ebp], eax

; 249  : 	{
; 250  : 		entities.push_back(&enemy);

	mov	eax, DWORD PTR _enemy$39[ebp]
	mov	DWORD PTR $T7[ebp], eax
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	lea	ecx, DWORD PTR _entities$[ebp]
	call	?push_back@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEX$$QAPAVEntity@@@Z ; std::vector<Entity *,std::allocator<Entity *> >::push_back

; 251  : 	}

	jmp	SHORT $LN5@main
$LN6@main:

; 252  : 	// shuffle them
; 253  : 	std::random_shuffle(entities.begin(), entities.end());

	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T6[ebp], esp
	push	eax
	lea	ecx, DWORD PTR _entities$[ebp]
	call	?end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	push	ecx
	lea	ecx, DWORD PTR _entities$[ebp]
	call	?begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@2@XZ ; std::vector<Entity *,std::allocator<Entity *> >::begin
	call	??$random_shuffle@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVEntity@@@std@@@std@@@0@0@Z ; std::random_shuffle<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Entity *> > > >
	add	esp, 24					; 00000018H

; 254  : 
; 255  : 	// print out the details of the entities doing the appropriate casts
; 256  : 	for (auto& entity : entities)

	lea	eax, DWORD PTR _entities$[ebp]
	mov	DWORD PTR _<range>$L2$38[ebp], eax
	mov	ecx, DWORD PTR _<range>$L2$38[ebp]
	call	?_Unchecked_begin@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_begin
	mov	DWORD PTR _<begin>$L2$37[ebp], eax
	mov	ecx, DWORD PTR _<range>$L2$38[ebp]
	call	?_Unchecked_end@?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAEPAPAVEntity@@XZ ; std::vector<Entity *,std::allocator<Entity *> >::_Unchecked_end
	mov	DWORD PTR _<end>$L2$36[ebp], eax
	jmp	SHORT $LN10@main
$LN8@main:
	mov	eax, DWORD PTR _<begin>$L2$37[ebp]
	add	eax, 4
	mov	DWORD PTR _<begin>$L2$37[ebp], eax
$LN10@main:
	mov	eax, DWORD PTR _<begin>$L2$37[ebp]
	cmp	eax, DWORD PTR _<end>$L2$36[ebp]
	je	$LN9@main
	mov	eax, DWORD PTR _<begin>$L2$37[ebp]
	mov	DWORD PTR _entity$35[ebp], eax

; 257  : 	{
; 258  : 		// check if the entity is a player
; 259  : 		if (dynamic_cast<Player*>(entity))

	push	0
	push	OFFSET ??_R0?AVPlayer@@@8
	push	OFFSET ??_R0?AVEntity@@@8
	push	0
	mov	eax, DWORD PTR _entity$35[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___RTDynamicCast
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN11@main

; 260  : 		{
; 261  : 			// cast the entity to a player and print out the details
; 262  : 			Player* player = dynamic_cast<Player*>(entity);

	push	0
	push	OFFSET ??_R0?AVPlayer@@@8
	push	OFFSET ??_R0?AVEntity@@@8
	push	0
	mov	eax, DWORD PTR _entity$35[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___RTDynamicCast
	add	esp, 20					; 00000014H
	mov	DWORD PTR _player$34[ebp], eax

; 263  : 			player->PrintPlayerName();

	mov	ecx, DWORD PTR _player$34[ebp]
	call	?PrintPlayerName@Player@@QAEXXZ		; Player::PrintPlayerName

; 264  : 			std::cout << " with gold ";  player->PrintGold();

	push	OFFSET ??_C@_0M@KCDFEKHC@?5with?5gold?5@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, DWORD PTR _player$34[ebp]
	call	?PrintGold@Player@@QAEXXZ		; Player::PrintGold

; 265  : 		}

	jmp	$LN12@main
$LN11@main:

; 266  : 		// check if the entity is an enemy
; 267  : 		else if (dynamic_cast<Enemy*>(entity))

	push	0
	push	OFFSET ??_R0?AVEnemy@@@8
	push	OFFSET ??_R0?AVEntity@@@8
	push	0
	mov	eax, DWORD PTR _entity$35[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___RTDynamicCast
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN12@main

; 268  : 		{
; 269  : 			// cast the entity to an enemy and print out the details
; 270  : 			Enemy* enemy = dynamic_cast<Enemy*>(entity);

	push	0
	push	OFFSET ??_R0?AVEnemy@@@8
	push	OFFSET ??_R0?AVEntity@@@8
	push	0
	mov	eax, DWORD PTR _entity$35[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	___RTDynamicCast
	add	esp, 20					; 00000014H
	mov	DWORD PTR _enemy$33[ebp], eax

; 271  : 			enemy->PrintEnemyName(); std::cout << " with health "; enemy->PrintHealth(); std::cout << " and gold drop "; enemy->PrintGoldDrop();

	mov	ecx, DWORD PTR _enemy$33[ebp]
	call	?PrintEnemyName@Enemy@@QAEXXZ		; Enemy::PrintEnemyName
	push	OFFSET ??_C@_0O@ONJBCCPN@?5with?5health?5@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, DWORD PTR _enemy$33[ebp]
	call	?PrintHealth@Enemy@@QAEXXZ		; Enemy::PrintHealth
	push	OFFSET ??_C@_0BA@KEIMIMCK@?5and?5gold?5drop?5@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, DWORD PTR _enemy$33[ebp]
	call	?PrintGoldDrop@Enemy@@QAEXXZ		; Enemy::PrintGoldDrop
$LN12@main:

; 272  : 		}
; 273  : 	}

	jmp	$LN8@main
$LN9@main:

; 274  : 
; 275  : 	// print hashcodes of everything
; 276  : 	std::cout << "hash of e:  " << hash_value(*e) << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	eax, DWORD PTR _e$[ebp]
	push	eax
	call	?hash_value@@YAIABVEntity@@@Z		; hash_value
	add	esp, 4
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0N@LFABCOLI@hash?5of?5e?3?5?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 277  : 	std::cout << "hash of e2: " << hash_value(*e2) << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	eax, DWORD PTR _e2$[ebp]
	push	eax
	call	?hash_value@@YAIABVEntity@@@Z		; hash_value
	add	esp, 4
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0N@GBAECAPB@hash?5of?5e2?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 278  : 	std::cout << "hash of e3: " << hash_value(*e3) << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	eax, DWORD PTR _e3$[ebp]
	push	eax
	call	?hash_value@@YAIABVEntity@@@Z		; hash_value
	add	esp, 4
	mov	edi, esp
	push	eax
	push	OFFSET ??_C@_0N@NJLIEHJE@hash?5of?5e3?3?5@
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@I@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 279  : 
; 280  : 
; 281  : 	std::cin.get();

	mov	esi, esp
	mov	ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_?get@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 282  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 43		; 0000002bH
	lea	ecx, DWORD PTR _entities$[ebp]
	call	??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	lea	ecx, DWORD PTR _enemies$[ebp]
	call	??1?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy,std::allocator<Enemy> >::~vector<Enemy,std::allocator<Enemy> >
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR _players$[ebp]
	call	??1?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ; std::vector<Player,std::allocator<Player> >::~vector<Player,std::allocator<Player> >
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _player2$[ebp]
	call	??1Player@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _player$[ebp]
	call	??1Entity@@UAE@XZ			; Entity::~Entity
	xor	eax, eax
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN67@main
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2084				; 00000824H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN67@main:
	DD	5
	DD	$LN66@main
$LN66@main:
	DD	-152					; ffffff68H
	DD	12					; 0000000cH
	DD	$LN60@main
	DD	-204					; ffffff34H
	DD	44					; 0000002cH
	DD	$LN61@main
	DD	-240					; ffffff10H
	DD	16					; 00000010H
	DD	$LN62@main
	DD	-264					; fffffef8H
	DD	16					; 00000010H
	DD	$LN63@main
	DD	-288					; fffffee0H
	DD	16					; 00000010H
	DD	$LN64@main
$LN64@main:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN63@main:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$LN62@main:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$LN61@main:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	50					; 00000032H
	DB	0
$LN60@main:
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$_main$1:
	mov	eax, DWORD PTR $T4[ebp]
	and	eax, 1
	je	$LN29@main
	and	DWORD PTR $T4[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T27[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN29@main:
	ret	0
__unwindfunclet$_main$2:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T25[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$_main$3:
	lea	ecx, DWORD PTR $T22[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$5:
	lea	ecx, DWORD PTR _player$[ebp]
	jmp	??1Entity@@UAE@XZ			; Entity::~Entity
__unwindfunclet$_main$6:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$7:
	lea	ecx, DWORD PTR _player2$[ebp]
	jmp	??1Player@@UAE@XZ
__unwindfunclet$_main$8:
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$9:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1Player@@UAE@XZ
__unwindfunclet$_main$10:
	lea	ecx, DWORD PTR $T18[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$11:
	lea	ecx, DWORD PTR $T2[ebp+44]
	jmp	??1Player@@UAE@XZ
__unwindfunclet$_main$12:
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$13:
	lea	ecx, DWORD PTR $T2[ebp+88]
	jmp	??1Player@@UAE@XZ
__unwindfunclet$_main$14:
	lea	ecx, DWORD PTR $T16[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$16:
	push	OFFSET ??1Player@@UAE@XZ
	push	4
	push	44					; 0000002cH
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$_main$17:
	lea	ecx, DWORD PTR _players$[ebp]
	jmp	??1?$vector@VPlayer@@V?$allocator@VPlayer@@@std@@@std@@QAE@XZ ; std::vector<Player,std::allocator<Player> >::~vector<Player,std::allocator<Player> >
__unwindfunclet$_main$18:
	lea	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$19:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1Enemy@@UAE@XZ
__unwindfunclet$_main$20:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$21:
	lea	ecx, DWORD PTR $T3[ebp+48]
	jmp	??1Enemy@@UAE@XZ
__unwindfunclet$_main$22:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$23:
	lea	ecx, DWORD PTR $T3[ebp+96]
	jmp	??1Enemy@@UAE@XZ
__unwindfunclet$_main$24:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$26:
	push	OFFSET ??1Enemy@@UAE@XZ
	push	4
	push	48					; 00000030H
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$_main$27:
	lea	ecx, DWORD PTR _enemies$[ebp]
	jmp	??1?$vector@VEnemy@@V?$allocator@VEnemy@@@std@@@std@@QAE@XZ ; std::vector<Enemy,std::allocator<Enemy> >::~vector<Enemy,std::allocator<Enemy> >
__unwindfunclet$_main$28:
	lea	ecx, DWORD PTR _entities$[ebp]
	jmp	??1?$vector@PAVEntity@@V?$allocator@PAVEntity@@@std@@@std@@QAE@XZ ; std::vector<Entity *,std::allocator<Entity *> >::~vector<Entity *,std::allocator<Entity *> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$_main:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2088]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$_main
	jmp	___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GEnemy@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GEnemy@@UAEPAXI@Z PROC				; Enemy::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Enemy@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GEnemy@@UAEPAXI@Z ENDP				; Enemy::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1Enemy@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Enemy@@UAE@XZ PROC					; Enemy::~Enemy, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Entity@@UAE@XZ			; Entity::~Entity
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Enemy@@UAE@XZ ENDP					; Enemy::~Enemy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??0Enemy@@QAE@$$QAV0@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??0Enemy@@QAE@$$QAV0@@Z PROC				; Enemy::Enemy, COMDAT
; _this$ = ecx

; 114  : 	Enemy(Enemy&& other) noexcept : m_Name(std::move(other.m_Name)), m_Health(other.m_Health), m_goldDrop(other.m_goldDrop) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Enemy@@QAE@$$QAV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Entity@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Enemy@@6B@
	mov	eax, DWORD PTR _other$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 115  : 		std::cout << "Enemy move constructor" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BH@KJLEBLJB@Enemy?5move?5constructor@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 116  : 		std::cout << "move constructing " << m_Name << " with health " << m_Health << " and gold drop " << m_goldDrop << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	OFFSET ??_C@_0BA@KEIMIMCK@?5and?5gold?5drop?5@
	mov	ebx, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	push	OFFSET ??_C@_0O@ONJBCCPN@?5with?5health?5@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET ??_C@_0BD@GHEIENED@move?5constructing?5@
	mov	edx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 117  : 
; 118  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0Enemy@@QAE@$$QAV0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Enemy@@QAE@$$QAV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Enemy@@QAE@$$QAV0@@Z ENDP				; Enemy::Enemy
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??0Enemy@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??0Enemy@@QAE@ABV0@@Z PROC				; Enemy::Enemy, COMDAT
; _this$ = ecx

; 107  : 	Enemy(const Enemy& other) : m_Name(other.m_Name), m_Health(other.m_Health), m_goldDrop(other.m_goldDrop) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Enemy@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Entity@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Enemy@@6B@
	mov	eax, DWORD PTR _other$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx

; 108  : 		std::cout << "Enemy copy constructor" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BH@IGCNJKLE@Enemy?5copy?5constructor@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 109  : 		std::cout << "copy constructing " << m_Name << " with health " << m_Health << " and gold drop " << m_goldDrop << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	OFFSET ??_C@_0BA@KEIMIMCK@?5and?5gold?5drop?5@
	mov	ebx, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	push	OFFSET ??_C@_0O@ONJBCCPN@?5with?5health?5@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET ??_C@_0BD@BFAEABIL@copy?5constructing?5@
	mov	edx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 110  : 
; 111  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Enemy@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Entity@@UAE@XZ			; Entity::~Entity
__unwindfunclet$??0Enemy@@QAE@ABV0@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0Enemy@@QAE@ABV0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Enemy@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Enemy@@QAE@ABV0@@Z ENDP				; Enemy::Enemy
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_health$ = 12						; size = 4
_goldDrop$ = 16						; size = 4
??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z PROC ; Enemy::Enemy, COMDAT
; _this$ = ecx

; 102  : 	Enemy(const std::string& name, int health, int goldDrop) : m_Name(name), m_Health(health), m_goldDrop(goldDrop) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Entity@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Enemy@@6B@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _health$[ebp]
	mov	DWORD PTR [eax+40], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _goldDrop$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 103  : 		std::cout << "Enemy constructor" << std::endl;

	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_0BC@IJCJGND@Enemy?5constructor@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 104  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Entity@@UAE@XZ			; Entity::~Entity
__unwindfunclet$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Enemy@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HH@Z ENDP ; Enemy::Enemy
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintGoldDrop@Enemy@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintGoldDrop@Enemy@@QAEXXZ PROC			; Enemy::PrintGoldDrop, COMDAT
; _this$ = ecx

; 99   : 	void PrintGoldDrop() { std::cout << m_goldDrop << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintGoldDrop@Enemy@@QAEXXZ ENDP			; Enemy::PrintGoldDrop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintEnemyName@Enemy@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintEnemyName@Enemy@@QAEXXZ PROC			; Enemy::PrintEnemyName, COMDAT
; _this$ = ecx

; 98   : 	void PrintEnemyName() { std::cout << m_Name << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintEnemyName@Enemy@@QAEXXZ ENDP			; Enemy::PrintEnemyName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintHealth@Enemy@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintHealth@Enemy@@QAEXXZ PROC				; Enemy::PrintHealth, COMDAT
; _this$ = ecx

; 97   : 	void PrintHealth() { std::cout << m_Health << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintHealth@Enemy@@QAEXXZ ENDP				; Enemy::PrintHealth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintName@Enemy@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintName@Enemy@@UAEXXZ PROC				; Enemy::PrintName, COMDAT
; _this$ = ecx

; 96   : 	virtual void PrintName() override { std::cout << "Enemy" << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_05IFKAJBFC@Enemy@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintName@Enemy@@UAEXXZ ENDP				; Enemy::PrintName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5367 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 5368 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

	mov	ecx, DWORD PTR __Str$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	call	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
	push	eax
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	call	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
	add	esp, 12					; 0000000cH

; 5369 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GPlayer@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GPlayer@@UAEPAXI@Z PROC				; Player::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Player@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPlayer@@UAEPAXI@Z ENDP				; Player::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1Player@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Player@@UAE@XZ PROC					; Player::~Player, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Entity@@UAE@XZ			; Entity::~Entity
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Player@@UAE@XZ ENDP					; Player::~Player
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??0Player@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??0Player@@QAE@ABV0@@Z PROC				; Player::Player, COMDAT
; _this$ = ecx

; 62   : 	Player(const Player& other) : m_Name(other.m_Name), m_Gold(other.m_Gold) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Player@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Entity@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Player@@6B@
	mov	eax, DWORD PTR _other$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Player@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Entity@@UAE@XZ			; Entity::~Entity
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0Player@@QAE@ABV0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Player@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Player@@QAE@ABV0@@Z ENDP				; Player::Player
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_gold$ = 12						; size = 4
??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Player::Player, COMDAT
; _this$ = ecx

; 59   : 	Player(const std::string& name, int gold) : m_Name(name), m_Gold(gold) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Entity@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Player@@6B@
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _gold$[ebp]
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Entity@@UAE@XZ			; Entity::~Entity
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Player@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Player::Player
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintPlayerName@Player@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintPlayerName@Player@@QAEXXZ PROC			; Player::PrintPlayerName, COMDAT
; _this$ = ecx

; 54   : 	void PrintPlayerName() { std::cout << m_Name << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	ecx
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintPlayerName@Player@@QAEXXZ ENDP			; Player::PrintPlayerName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintGold@Player@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintGold@Player@@QAEXXZ PROC				; Player::PrintGold, COMDAT
; _this$ = ecx

; 53   : 	void PrintGold() { std::cout << m_Gold << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintGold@Player@@QAEXXZ ENDP				; Player::PrintGold
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintName@Player@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintName@Player@@UAEXXZ PROC				; Player::PrintName, COMDAT
; _this$ = ecx

; 52   : 	virtual void PrintName() override { std::cout << "Player" << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_06NPAAKFED@Player@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintName@Player@@UAEXXZ ENDP				; Player::PrintName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??$hash_combine@MM@@YAIABM0@Z
_TEXT	SEGMENT
_seed$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_<args_0>$ = 8						; size = 4
_<args_1>$ = 12						; size = 4
??$hash_combine@MM@@YAIABM0@Z PROC			; hash_combine<float,float>, COMDAT

; 22   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 23   :     std::size_t seed = 0;

	mov	DWORD PTR _seed$[ebp], 0

; 24   :     hash_combine_impl(seed, args...);

	mov	eax, DWORD PTR _<args_1>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<args_0>$[ebp]
	push	ecx
	lea	edx, DWORD PTR _seed$[ebp]
	push	edx
	call	??$hash_combine_impl@MM@@YAXAAIABM1@Z	; hash_combine_impl<float,float>
	add	esp, 12					; 0000000cH

; 25   :     return seed;

	mov	eax, DWORD PTR _seed$[ebp]

; 26   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@hash_combi
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@hash_combi:
	DD	1
	DD	$LN4@hash_combi
$LN4@hash_combi:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN3@hash_combi
$LN3@hash_combi:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
??$hash_combine@MM@@YAIABM0@Z ENDP			; hash_combine<float,float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1005 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __47FEFEA8_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 1006 :     _Ostr.put(_Ostr.widen('\n'));

	mov	esi, esp
	push	10					; 0000000aH
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1007 :     _Ostr.flush();

	mov	esi, esp
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1008 :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]

; 1009 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -356						; size = 8
tv343 = -348						; size = 8
tv291 = -344						; size = 4
tv288 = -344						; size = 8
tv286 = -344						; size = 4
tv329 = -340						; size = 8
tv290 = -340						; size = 4
tv285 = -340						; size = 4
tv287 = -336						; size = 4
tv137 = -336						; size = 4
tv289 = -333						; size = 1
tv284 = -333						; size = 1
$T2 = -328						; size = 4
$T3 = -316						; size = 4
$T4 = -304						; size = 4
$T5 = -292						; size = 4
$T6 = -280						; size = 4
__Ok$ = -76						; size = 8
__Pad$ = -60						; size = 8
__Count$ = -44						; size = 8
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 761  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ecx, OFFSET __47FEFEA8_ostream
	call	@__CheckForDebuggerJustMyCode@4

; 762  :     // insert NTBS into char stream
; 763  :     using _Elem = char;
; 764  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 765  : 
; 766  :     ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 767  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	xor	ecx, ecx
	mov	DWORD PTR __Count$[ebp], eax
	mov	DWORD PTR __Count$[ebp+4], ecx

; 768  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv329[ebp], eax
	mov	DWORD PTR tv329[ebp+4], edx
	cmp	DWORD PTR tv329[ebp+4], 0
	jl	SHORT $LN17@operator
	jg	SHORT $LN24@operator
	cmp	DWORD PTR tv329[ebp], 0
	jbe	SHORT $LN17@operator
$LN24@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv343[ebp], eax
	mov	DWORD PTR tv343[ebp+4], edx
	mov	eax, DWORD PTR tv343[ebp+4]
	cmp	eax, DWORD PTR __Count$[ebp+4]
	jl	SHORT $LN17@operator
	jg	SHORT $LN25@operator
	mov	ecx, DWORD PTR tv343[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jbe	SHORT $LN17@operator
$LN25@operator:
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	esi, esp
	call	DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR __Count$[ebp]
	sbb	edx, DWORD PTR __Count$[ebp+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	DWORD PTR tv135[ebp+4], edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv135[ebp], xmm0
$LN18@operator:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	edx, DWORD PTR tv135[ebp+4]
	mov	DWORD PTR __Pad$[ebp], ecx
	mov	DWORD PTR __Pad$[ebp+4], edx

; 769  :     const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 770  : 
; 771  :     if (!_Ok) {

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@operator

; 772  :         _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 773  :     } else { // state okay, insert

	jmp	$LN9@operator
$LN8@operator:

; 774  :         _TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 775  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv137[ebp], eax
	mov	eax, DWORD PTR tv137[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator

; 776  :             for (; 0 < _Pad; --_Pad) { // pad on left

	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN11@operator
	jg	SHORT $LN26@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN11@operator
$LN26@operator:

; 777  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv284[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv285[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv284[ebp]
	push	eax
	mov	ecx, DWORD PTR tv285[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR tv286[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T5[ebp], eax
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@operator

; 778  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 779  :                     break;

	jmp	SHORT $LN11@operator
$LN12@operator:

; 780  :                 }
; 781  :             }

	jmp	$LN2@operator
$LN11@operator:

; 782  :         }
; 783  : 
; 784  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN13@operator
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv287[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv287[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv288[ebp], eax
	mov	DWORD PTR tv288[ebp+4], edx
	mov	eax, DWORD PTR tv288[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jne	SHORT $LN27@operator
	mov	ecx, DWORD PTR tv288[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp+4]
	je	SHORT $LN13@operator
$LN27@operator:

; 785  :             _State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN13@operator:

; 786  :         }
; 787  : 
; 788  :         if (_State == ios_base::goodbit) {

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN14@operator

; 789  :             for (; 0 < _Pad; --_Pad) { // pad on right

	jmp	SHORT $LN7@operator
$LN5@operator:
	mov	eax, DWORD PTR __Pad$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR __Pad$[ebp+4]
	sbb	ecx, 0
	mov	DWORD PTR __Pad$[ebp], eax
	mov	DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
	cmp	DWORD PTR __Pad$[ebp+4], 0
	jl	$LN14@operator
	jg	SHORT $LN28@operator
	cmp	DWORD PTR __Pad$[ebp], 0
	jbe	$LN14@operator
$LN28@operator:

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	BYTE PTR tv289[ebp], al
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	ecx, edx
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv290[ebp], eax
	mov	esi, esp
	movzx	eax, BYTE PTR tv289[ebp]
	push	eax
	mov	ecx, DWORD PTR tv290[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv291[ebp], eax
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	call	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
	mov	DWORD PTR $T3[ebp], eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@operator

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 792  :                     break;

	jmp	SHORT $LN14@operator
$LN15@operator:

; 793  :                 }
; 794  :             }

	jmp	$LN5@operator
$LN14@operator:

; 795  :         }
; 796  : 
; 797  :         _Ostr.width(0);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 798  :         _CATCH_IO_(ios_base, _Ostr)

	mov	esi, esp
	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, $LN23@operator
	ret	0
$LN19@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN9@operator
$LN23@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 799  :     }
; 800  : 
; 801  :     _Ostr.setstate(_State);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 802  :     return _Ostr;

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T2[ebp]

; 803  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN32@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 356				; 00000164H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN32@operator:
	DD	1
	DD	$LN31@operator
$LN31@operator:
	DD	-76					; ffffffb4H
	DD	8
	DD	$LN29@operator
$LN29@operator:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_GEntity@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_GEntity@@UAEPAXI@Z PROC				; Entity::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Entity@@UAE@XZ			; Entity::~Entity
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GEntity@@UAEPAXI@Z ENDP				; Entity::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Entity@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0Entity@@QAE@ABV0@@Z PROC				; Entity::Entity, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Entity@@6B@
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Entity@@QAE@ABV0@@Z ENDP				; Entity::Entity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Entity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Entity@@QAE@XZ PROC					; Entity::Entity, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Entity@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Entity@@QAE@XZ ENDP					; Entity::Entity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?hash_value@@YAIABVEntity@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?hash_value@@YAIABVEntity@@@Z PROC			; hash_value, COMDAT

; 42   : 	friend std::size_t hash_value(const Entity& e) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 43   : 		return hash_combine(e.m_Position.x, e.m_Position.y);

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	add	ecx, 4
	push	ecx
	call	??$hash_combine@MM@@YAIABM0@Z		; hash_combine<float,float>
	add	esp, 8

; 44   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?hash_value@@YAIABVEntity@@@Z ENDP			; hash_value
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ??1Entity@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1Entity@@UAE@XZ PROC					; Entity::~Entity, COMDAT
; _this$ = ecx

; 39   : 	virtual ~Entity() = default; // virtual destructor to make sure the correct destructor is called when deleting a pointer to a derived class.

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Entity@@UAE@XZ ENDP					; Entity::~Entity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintPosition@Entity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintPosition@Entity@@UAEXXZ PROC			; Entity::PrintPosition, COMDAT
; _this$ = ecx

; 37   : 	virtual void PrintPosition() { std::cout << m_Position.x << ", " << m_Position.y << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	edi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+8]
	movss	DWORD PTR [esp], xmm0
	push	OFFSET ??_C@_02KEGNLNML@?0?5@
	mov	ebx, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	cmp	ebx, esp
	call	__RTC_CheckEsp
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintPosition@Entity@@UAEXXZ ENDP			; Entity::PrintPosition
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\castingSafu.cpp
;	COMDAT ?PrintName@Entity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?PrintName@Entity@@UAEXXZ PROC				; Entity::PrintName, COMDAT
; _this$ = ecx

; 36   : 	virtual void PrintName() { std::cout << "Entity" << std::endl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __230C1D2E_castingSafu@cpp
	call	@__CheckForDebuggerJustMyCode@4
	mov	esi, esp
	push	OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
	push	OFFSET ??_C@_06KBCHOIMA@Entity@
	mov	eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintName@Entity@@UAEXXZ ENDP				; Entity::PrintName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Ptr_container$ = -20					; size = 4
__Block_size$ = -8					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 127  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 128  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 129  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[ebp]
	add	eax, 39					; 00000027H
	mov	DWORD PTR __Block_size$[ebp], eax

; 130  :     if (_Block_size <= _Bytes) {

	mov	eax, DWORD PTR __Block_size$[ebp]
	cmp	eax, DWORD PTR __Bytes$[ebp]
	ja	SHORT $LN8@Allocate_m

; 131  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 132  :     }
; 133  : 
; 134  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	eax, DWORD PTR __Block_size$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 135  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	DWORD PTR __Ptr_container$[ebp], 0
	je	SHORT $LN7@Allocate_m
	jmp	SHORT $LN2@Allocate_m
$LN7@Allocate_m:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	135					; 00000087H
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@Allocate_m
	int	3
$LN12@Allocate_m:
	mov	esi, esp
	push	0
	push	135					; 00000087H
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN2@Allocate_m:
	xor	eax, eax
	jne	SHORT $LN4@Allocate_m

; 136  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	eax, DWORD PTR __Ptr_container$[ebp]
	add	eax, 39					; 00000027H
	and	eax, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$[ebp], eax

; 137  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 138  : 
; 139  : #ifdef _DEBUG
; 140  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+ecx], -84215046		; fafafafaH

; 141  : #endif // _DEBUG
; 142  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 143  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 659  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 660  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 661  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 662  :         if (_STD is_constant_evaluated()) {
; 663  :             _Al.deallocate(_Ptr, _Count);
; 664  :         } else
; 665  : #endif // _HAS_CXX20
; 666  :         {
; 667  :             (void) _Al;
; 668  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 669  :         }
; 670  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z PROC ; std::_Voidify_iter<std::_Container_proxy *>, COMDAT

; 244  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 245  :     if constexpr (is_pointer_v<_Iter>) {
; 246  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, DWORD PTR __It$[ebp]

; 247  :     } else {
; 248  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 249  :     }
; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ENDP ; std::_Voidify_iter<std::_Container_proxy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 280  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 282  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 0

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 60   :         if (_Count > _Max_possible) {
; 61   :             _Throw_bad_array_new_length(); // multiply overflow
; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	jbe	SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
$LN3@Get_size_o:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 221  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 222  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 223  : #if defined(_M_IX86) || defined(_M_X64)
; 224  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 225  :     if (!_STD is_constant_evaluated())
; 226  : #endif // _HAS_CXX20
; 227  :     {
; 228  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Allocate

; 229  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 230  :         }
; 231  :     }
; 232  : #endif // defined(_M_IX86) || defined(_M_X64)
; 233  : 
; 234  :     if (_Bytes != 0) {

	cmp	DWORD PTR __Bytes$[ebp], 0
	je	SHORT $LN3@Allocate

; 235  :         return _Traits::_Allocate(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
	add	esp, 4
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 236  :     }
; 237  : 
; 238  :     return nullptr;

	xor	eax, eax
$LN1@Allocate:

; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if constexpr (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 60   :         if (_Count > _Max_possible) {

	cmp	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH
	jbe	SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
$LN3@Get_size_o:

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z PROC		; std::_Voidify_iter<char * *>, COMDAT

; 244  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 245  :     if constexpr (is_pointer_v<_Iter>) {
; 246  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

	mov	eax, DWORD PTR __It$[ebp]

; 247  :     } else {
; 248  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 249  :     }
; 250  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ENDP		; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 280  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 282  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 268  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 269  : #if _HAS_CXX20
; 270  :     if (_STD is_constant_evaluated()) {
; 271  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 272  :     } else
; 273  : #endif // _HAS_CXX20
; 274  :     {
; 275  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	call	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 276  :     }
; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 293  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 294  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1339 :     _CONSTEXPR20 ~_Container_proxy_ptr12() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1340 :         if (_Ptr) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Container_

; 1341 :             _Delete_plain_internal(_Al, _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8
$LN3@Container_:

; 1342 :         }
; 1343 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1325 :     _CONSTEXPR20 _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Al_$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1326 :         // create a new _Container_proxy pointing at _Mycont
; 1327 :         _Ptr = _Unfancy(_Al_.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al_$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1328 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

	mov	eax, DWORD PTR __Mycont$[ebp]
	push	eax
	call	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1329 :         _Mycont._Myproxy = _Ptr;

	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1330 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 979  : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 980  :     // deallocate a plain pointer using an allocator
; 981  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 982  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 983  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	push	1
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	add	esp, 12					; 0000000cH

; 984  :     } else {
; 985  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 986  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 987  :     }
; 988  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\type_traits
;	COMDAT ??$_Fnv1a_append_value@M@std@@YAIIABM@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Fnv1a_append_value@M@std@@YAIIABM@Z PROC		; std::_Fnv1a_append_value<float>, COMDAT

; 2141 :     const size_t _Val, const _Kty& _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1F1E5892_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2142 :     static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
; 2143 :     return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));

	push	4
	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Fnv1a_append_bytes@std@@YAIIQBEI@Z	; std::_Fnv1a_append_bytes
	add	esp, 12					; 0000000cH

; 2144 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fnv1a_append_value@M@std@@YAIIABM@Z ENDP		; std::_Fnv1a_append_value<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 280  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 282  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 280  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 282  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 242  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 243  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 244  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 245  :     if (_STD is_constant_evaluated()) {
; 246  :         ::operator delete(_Ptr);
; 247  :     } else
; 248  : #endif // _HAS_CXX20
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	DWORD PTR __Bytes$[ebp], 4096		; 00001000H
	jb	SHORT $LN2@Deallocate

; 252  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
	add	esp, 8
$LN2@Deallocate:

; 253  :         }
; 254  : #endif // defined(_M_IX86) || defined(_M_X64)
; 255  :         ::operator delete(_Ptr, _Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 256  :     }
; 257  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 41   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9596B502_utility
	call	@__CheckForDebuggerJustMyCode@4

; 42   :     // return larger of _Left and _Right
; 43   :     return _Left < _Right ? _Right : _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@max
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@max:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 44   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 293  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 294  :     return _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z PROC	; std::_Construct_in_place<char *,char * &>, COMDAT

; 268  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 269  : #if _HAS_CXX20
; 270  :     if (_STD is_constant_evaluated()) {
; 271  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 272  :     } else
; 273  : #endif // _HAS_CXX20
; 274  :     {
; 275  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@PAD@std@@YAPAPADAAPAD@Z	; std::addressof<char *>
	add	esp, 4
	push	eax
	call	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
	add	esp, 4
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 276  :     }
; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ENDP	; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 294  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__New_ptr$ = -112					; size = 4
__New_capacity$ = -100					; size = 4
__Proxy$ = -88						; size = 8
_$S11$ = -69						; size = 1
__Alproxy$ = -60					; size = 4
__Al$ = -48						; size = 4
__My_data$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT
; _this$ = ecx

; 2729 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 296				; 00000128H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2730 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2731 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2732 : 
; 2733 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2734 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2735 :         } else {
; 2736 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2737 :         }
; 2738 : 
; 2739 :         if (_Count > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Construct

; 2740 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2741 :         }
; 2742 : 
; 2743 :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2744 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	lea	ecx, DWORD PTR _$S11$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	ecx, DWORD PTR _$S11$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], ecx

; 2745 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2746 : 
; 2747 :         if (_Count < _BUF_SIZE) {

	cmp	DWORD PTR __Count$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Construct

; 2748 :             _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2749 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2750 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2751 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2752 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2753 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2754 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);
; 2755 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2756 :             } else { // _Strat == _Construct_strategy::_From_string
; 2757 : #ifdef _INSERT_STRING_ANNOTATION
; 2758 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2759 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2760 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

	push	16					; 00000010H
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 2761 : #endif // !_INSERT_STRING_ANNOTATION
; 2762 :             }
; 2763 : 
; 2764 :             _ASAN_STRING_CREATE(*this);
; 2765 :             _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2766 :             return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	jmp	$LN4@Construct
$LN3@Construct:

; 2767 :         }
; 2768 : 
; 2769 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2770 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 2771 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 2772 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 2773 : 
; 2774 : #if _HAS_CXX20
; 2775 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2776 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2777 :         }
; 2778 : #endif // _HAS_CXX20
; 2779 : 
; 2780 :         _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2781 :         _My_data._Myres  = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2782 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2783 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2784 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2785 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2786 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2787 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2788 :         } else { // _Strat == _Construct_strategy::_From_string
; 2789 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2790 :         }
; 2791 : 
; 2792 :         _ASAN_STRING_CREATE(*this);
; 2793 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2794 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
$LN4@Construct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 308				; 00000134H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN11@Construct:
	DD	3
	DD	$LN10@Construct
$LN10@Construct:
	DD	-69					; ffffffbbH
	DD	1
	DD	$LN6@Construct
	DD	-88					; ffffffa8H
	DD	8
	DD	$LN7@Construct
	DD	-112					; ffffff90H
	DD	4
	DD	$LN8@Construct
$LN8@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN7@Construct:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	49					; 00000031H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-312]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
$T2 = -325						; size = 1
$T3 = -313						; size = 1
__New_ptr$ = -112					; size = 4
__New_capacity$ = -100					; size = 4
__Proxy$ = -88						; size = 8
_$S10$ = -69						; size = 1
__Alproxy$ = -60					; size = 4
__Al$ = -48						; size = 4
__My_data$ = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 2729 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2730 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 2731 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2732 : 
; 2733 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2734 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2735 :         } else {
; 2736 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2737 :         }
; 2738 : 
; 2739 :         if (_Count > max_size()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Construct

; 2740 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
$LN2@Construct:

; 2741 :         }
; 2742 : 
; 2743 :         auto& _Al       = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$[ebp], eax

; 2744 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	lea	ecx, DWORD PTR _$S10$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	ecx, DWORD PTR _$S10$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], ecx

; 2745 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

	mov	eax, DWORD PTR __My_data$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2746 : 
; 2747 :         if (_Count < _BUF_SIZE) {

	cmp	DWORD PTR __Count$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Construct

; 2748 :             _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2749 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2750 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2751 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2752 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2753 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2754 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __My_data$[ebp]
	add	edx, 4
	push	edx
	call	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
	add	esp, 12					; 0000000cH

; 2755 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

	mov	BYTE PTR $T3[ebp], 0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __My_data$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2756 :             } else { // _Strat == _Construct_strategy::_From_string
; 2757 : #ifdef _INSERT_STRING_ANNOTATION
; 2758 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2759 : #else // ^^^ _INSERT_STRING_ANNOTATION ^^^ // vvv !_INSERT_STRING_ANNOTATION vvv
; 2760 :                 _Traits::move(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2761 : #endif // !_INSERT_STRING_ANNOTATION
; 2762 :             }
; 2763 : 
; 2764 :             _ASAN_STRING_CREATE(*this);
; 2765 :             _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2766 :             return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	jmp	$LN4@Construct
$LN3@Construct:

; 2767 :         }
; 2768 : 
; 2769 :         _My_data._Myres               = _BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 2770 :         const size_type _New_capacity = _Calculate_growth(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	DWORD PTR __New_capacity$[ebp], eax

; 2771 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	eax, DWORD PTR __New_capacity$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __New_ptr$[ebp], eax

; 2772 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	lea	eax, DWORD PTR __New_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
	add	esp, 8

; 2773 : 
; 2774 : #if _HAS_CXX20
; 2775 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB
; 2776 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());
; 2777 :         }
; 2778 : #endif // _HAS_CXX20
; 2779 : 
; 2780 :         _My_data._Mysize = _Count;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2781 :         _My_data._Myres  = _New_capacity;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __New_capacity$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2782 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2783 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2784 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2785 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2786 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_ptr$[ebp]
	push	edx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 2787 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR __New_ptr$[ebp]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 2788 :         } else { // _Strat == _Construct_strategy::_From_string
; 2789 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2790 :         }
; 2791 : 
; 2792 :         _ASAN_STRING_CREATE(*this);
; 2793 :         _Proxy._Release();

	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2794 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Proxy$[ebp]
	call	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
$LN4@Construct:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@Construct
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN11@Construct:
	DD	3
	DD	$LN10@Construct
$LN10@Construct:
	DD	-69					; ffffffbbH
	DD	1
	DD	$LN6@Construct
	DD	-88					; ffffffa8H
	DD	8
	DD	$LN7@Construct
	DD	-112					; ffffff90H
	DD	4
	DD	$LN8@Construct
$LN8@Construct:
	DB	95					; 0000005fH
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$LN7@Construct:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
$LN6@Construct:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	49					; 00000031H
	DB	48					; 00000030H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z$0:
	lea	ecx, DWORD PTR __Proxy$[ebp]
	jmp	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-336]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1375 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1380 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 822  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Convert_size@II@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@II@std@@YAII@Z PROC			; std::_Convert_size<unsigned int,unsigned int>, COMDAT

; 964  :     sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 965  :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 966  :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 967  :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 968  : 
; 969  :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 970  :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 971  :             _Xlength_error("size is too long for _Size_type");
; 972  :         }
; 973  :     }
; 974  : 
; 975  :     return static_cast<_Size_type>(_Len);

	mov	eax, DWORD PTR __Len$[ebp]

; 976  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Convert_size@II@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
__New_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1063 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1064 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	push	1
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	DWORD PTR __New_proxy$[ebp], eax

; 1065 :         _Construct_in_place(*_New_proxy, this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __New_proxy$[ebp]
	push	edx
	call	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	add	esp, 8

; 1066 :         _Myproxy            = _New_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __New_proxy$[ebp]
	mov	DWORD PTR [eax], ecx

; 1067 :         _New_proxy->_Mycont = this;

	mov	eax, DWORD PTR __New_proxy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 1068 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 991  : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 992  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 993  :     using _Ty = typename _Alloc::value_type;
; 994  :     _Ptr->~_Ty();
; 995  :     _Deallocate_plain(_Al, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 996  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 832  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 833  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 834  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$07@std@@YAII@Z	; std::_Get_size_of_n<8>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 835  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 64   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9596B502_utility
	call	@__CheckForDebuggerJustMyCode@4

; 65   :     // return smaller of _Left and _Right
; 66   :     return _Right < _Left ? _Right : _Left;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN3@min
	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
$LN4@min:
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ??R_Rand_urng_from_func@std@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??R_Rand_urng_from_func@std@@QAEIXZ PROC		; std::_Rand_urng_from_func::operator(), COMDAT
; _this$ = ecx

; 5279 :     result_type operator()() { // invoke rand()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4

; 5280 :         return static_cast<result_type>(_CSTD rand());

	mov	esi, esp
	call	DWORD PTR __imp__rand
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5281 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??R_Rand_urng_from_func@std@@QAEIXZ ENDP		; std::_Rand_urng_from_func::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ?max@_Rand_urng_from_func@std@@SAIXZ
_TEXT	SEGMENT
?max@_Rand_urng_from_func@std@@SAIXZ PROC		; std::_Rand_urng_from_func::max, COMDAT

; 5275 :     static result_type(max)() { // return maximum possible generated value

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4

; 5276 :         return RAND_MAX;

	mov	eax, 32767				; 00007fffH

; 5277 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max@_Rand_urng_from_func@std@@SAIXZ ENDP		; std::_Rand_urng_from_func::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\algorithm
;	COMDAT ?min@_Rand_urng_from_func@std@@SAIXZ
_TEXT	SEGMENT
?min@_Rand_urng_from_func@std@@SAIXZ PROC		; std::_Rand_urng_from_func::min, COMDAT

; 5271 :     static result_type(min)() { // return minimum possible generated value

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __2258C6CF_algorithm
	call	@__CheckForDebuggerJustMyCode@4

; 5272 :         return 0;

	xor	eax, eax

; 5273 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?min@_Rand_urng_from_func@std@@SAIXZ ENDP		; std::_Rand_urng_from_func::min
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1386 :     constexpr const _Ty1& _Get_first() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1387 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1388 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1382 :     constexpr _Ty1& _Get_first() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1383 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1384 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 5042 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 5043 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 5044 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 5038 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 5039 :         return _Mypair._Get_first();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 5040 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 5034 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 5035 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators

; 5036 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T2 = -257						; size = 1
__Al$3 = -56						; size = 4
__Ptr$4 = -44						; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 5010 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-72]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 5011 :         auto& _My_data = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 5012 :         _My_data._Orphan_all();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 5013 :         _ASAN_STRING_REMOVE(*this);
; 5014 :         if (_My_data._Large_string_engaged()) {

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 5015 :             const pointer _Ptr = _My_data._Bx._Ptr;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$4[ebp], ecx

; 5016 :             auto& _Al          = _Getal();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	DWORD PTR __Al$3[ebp], eax

; 5017 :             _Destroy_in_place(_My_data._Bx._Ptr);

	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
	add	esp, 4

; 5018 :             _My_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 5019 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$4[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$3[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 5020 :         }
; 5021 : 
; 5022 :         _My_data._Mysize = 0;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+20], 0

; 5023 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 5024 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5025 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T2[ebp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __My_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 5026 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 264				; 00000108H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -221						; size = 1
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4999 :     _CONSTEXPR20 void _Tidy_init() noexcept { // initialize basic_string data members

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 5000 :         auto& _My_data   = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 5001 :         _My_data._Mysize = 0;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+20], 0

; 5002 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	DWORD PTR [eax+24], 15			; 0000000fH

; 5003 :         _My_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 5004 : 
; 5005 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5006 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR __My_data$[ebp]
	lea	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
	add	esp, 8

; 5007 :         _ASAN_STRING_CREATE(*this);
; 5008 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4898 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4899 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR __Requested$[ebp]
	push	edx
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	add	esp, 12					; 0000000cH

; 4900 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -216						; size = 4
__Masked$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4885 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4886 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	eax, DWORD PTR __Requested$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Masked$[ebp], eax

; 4887 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	eax, DWORD PTR __Masked$[ebp]
	cmp	eax, DWORD PTR __Max$[ebp]
	jbe	SHORT $LN2@Calculate_

; 4888 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4889 :         }
; 4890 : 
; 4891 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	eax, DWORD PTR __Old$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR __Max$[ebp]
	sub	ecx, eax
	cmp	DWORD PTR __Old$[ebp], ecx
	jbe	SHORT $LN3@Calculate_

; 4892 :             return _Max;

	mov	eax, DWORD PTR __Max$[ebp]
	jmp	SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4893 :         }
; 4894 : 
; 4895 :         return (_STD max)(_Masked, _Old + _Old / 2);

	mov	eax, DWORD PTR __Old$[ebp]
	shr	eax, 1
	add	eax, DWORD PTR __Old$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	edx, DWORD PTR __Masked$[ebp]
	push	edx
	call	??$max@I@std@@YAABIABI0@Z		; std::max<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4896 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN7@Calculate_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN7@Calculate_:
	DD	1
	DD	$LN6@Calculate_
$LN6@Calculate_:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN5@Calculate_
$LN5@Calculate_:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -264						; size = 4
$T2 = -252						; size = 4
$T3 = -240						; size = 4
__Storage_max$ = -36					; size = 4
__Alloc_max$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 4279 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4280 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	add	esp, 4
	mov	DWORD PTR __Alloc_max$[ebp], eax

; 4281 :         const size_type _Storage_max = // can always store small string

	mov	DWORD PTR $T3[ebp], 16			; 00000010H
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR __Alloc_max$[ebp]
	push	ecx
	call	??$max@I@std@@YAABIABI0@Z		; std::max<unsigned int>
	add	esp, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Storage_max$[ebp], edx

; 4282 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4283 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	eax, DWORD PTR __Storage_max$[ebp]
	sub	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	call	?max@?$numeric_limits@H@std@@SAHXZ	; std::numeric_limits<int>::max
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$min@I@std@@YAABIABI0@Z		; std::min<unsigned int>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 4284 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4285 :         );
; 4286 :     }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@max_size
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@max_size:
	DD	1
	DD	$LN4@max_size
$LN4@max_size:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@max_size
$LN3@max_size:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	120					; 00000078H
	DB	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 4275 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4276 :         return _Mypair._Myval2._Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 4277 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 4261 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 4262 :         return _Mypair._Myval2._Myptr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4263 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -48					; size = 4
_$S4$ = -33						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3269 :     _CONSTEXPR20 ~basic_string() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3270 :         _Tidy_deallocate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3271 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3272 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR _$S4$[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	eax, DWORD PTR _$S4$[ebp]
	mov	DWORD PTR __Alproxy$[ebp], eax

; 3273 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __To_delete$[ebp], ecx

; 3274 :         _Mypair._Myval2._Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 3275 :         _Delete_plain_internal(_Alproxy, _To_delete);

	mov	eax, DWORD PTR __To_delete$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Alproxy$[ebp]
	push	ecx
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	add	esp, 8

; 3276 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3277 :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@basic_stri
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN5@basic_stri:
	DD	1
	DD	$LN4@basic_stri
$LN4@basic_stri:
	DD	-33					; ffffffdfH
	DD	1
	DD	$LN3@basic_stri
$LN3@basic_stri:
	DB	36					; 00000024H
	DB	83					; 00000053H
	DB	52					; 00000034H
	DB	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__Right_data$ = -44					; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 3142 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3143 :         // assign by stealing _Right's buffer
; 3144 :         // pre: this != &_Right
; 3145 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3146 :         // pre: *this owns no memory, iterators orphaned
; 3147 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3148 :         auto& _My_data    = _Mypair._Myval2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __My_data$[ebp], eax

; 3149 :         auto& _Right_data = _Right._Mypair._Myval2;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	DWORD PTR __Right_data$[ebp], eax

; 3150 : 
; 3151 :         if constexpr (_Can_memcpy_val) {
; 3152 : #if _HAS_CXX20
; 3153 :             if (!_STD is_constant_evaluated())
; 3154 : #endif // _HAS_CXX20
; 3155 :             {
; 3156 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3157 :                 if (_Right_data._Large_string_engaged()) {

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Take_conte

; 3158 :                     // take ownership of _Right's iterators along with its buffer
; 3159 :                     _Swap_proxy_and_iterators(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3160 :                 } else {

	jmp	SHORT $LN3@Take_conte
$LN2@Take_conte:

; 3161 :                     _Right_data._Orphan_all();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
$LN3@Take_conte:

; 3162 :                 }
; 3163 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3164 : 
; 3165 : #ifdef _INSERT_STRING_ANNOTATION
; 3166 :                 if (!_Right_data._Large_string_engaged()) {
; 3167 :                     _ASAN_STRING_REMOVE(_Right);
; 3168 :                 }
; 3169 : #endif // _INSERT_STRING_ANNOTATION
; 3170 : 
; 3171 :                 _Memcpy_val_from(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from

; 3172 : 
; 3173 : #ifdef _INSERT_STRING_ANNOTATION
; 3174 :                 if (!_Right_data._Large_string_engaged()) {
; 3175 :                     _ASAN_STRING_REMOVE(_Right);
; 3176 :                     _ASAN_STRING_CREATE(*this);
; 3177 :                 }
; 3178 : #endif // _INSERT_STRING_ANNOTATION
; 3179 : 
; 3180 :                 _Right._Tidy_init();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 3181 :                 return;

	jmp	$LN6@Take_conte

; 3182 :             }
; 3183 :         }
; 3184 : 
; 3185 :         if (_Right_data._Large_string_engaged()) { // steal buffer

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Take_conte

; 3186 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

	mov	eax, DWORD PTR __Right_data$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __My_data$[ebp]
	add	ecx, 4
	push	ecx
	call	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
	add	esp, 8

; 3187 :             _Right_data._Bx._Ptr = nullptr;

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	DWORD PTR [eax+4], 0

; 3188 :             _Swap_proxy_and_iterators(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3189 :         } else { // copy small string buffer

	jmp	SHORT $LN5@Take_conte
$LN4@Take_conte:

; 3190 :             _My_data._Activate_SSO_buffer();

	mov	ecx, DWORD PTR __My_data$[ebp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 3191 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

	mov	eax, DWORD PTR __Right_data$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Right_data$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR __My_data$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
	add	esp, 12					; 0000000cH

; 3192 :             _Right_data._Orphan_all();

	mov	ecx, DWORD PTR __Right_data$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
$LN5@Take_conte:

; 3193 :         }
; 3194 : 
; 3195 :         _My_data._Mysize = _Right_data._Mysize;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Right_data$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 3196 :         _My_data._Myres  = _Right_data._Myres;

	mov	eax, DWORD PTR __My_data$[ebp]
	mov	ecx, DWORD PTR __Right_data$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 3197 :         _Right._Tidy_init();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
$LN6@Take_conte:

; 3198 :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Right_data_mem$ = -32					; size = 4
__My_data_mem$ = -20					; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT
; _this$ = ecx

; 3133 :     void _Memcpy_val_from(const basic_string& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 3134 :         _STL_INTERNAL_CHECK(_Can_memcpy_val);
; 3135 :         const auto _My_data_mem =

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __My_data_mem$[ebp], eax

; 3136 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3137 :         const auto _Right_data_mem =

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
	add	esp, 4
	add	eax, 4
	mov	DWORD PTR __Right_data_mem$[ebp], eax

; 3138 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3139 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	push	24					; 00000018H
	mov	eax, DWORD PTR __Right_data_mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR __My_data_mem$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3140 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2890 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	movzx	eax, BYTE PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2891 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2892 :         _Take_contents(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2893 :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	int	3
	int	3
	int	3
	int	3
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2673 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4
	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2674 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
	add	esp, 4
	push	eax
	call	??$_Convert_size@II@std@@YAII@Z		; std::_Convert_size<unsigned int,unsigned int>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2675 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -233						; size = 1
$T3 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2625 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2626 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>

; 2627 :     }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
	int	3
	int	3
	int	3
	int	3
	int	3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
	npad	1
	npad	1
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2341 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2340 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 2303 :     constexpr void _Activate_SSO_buffer() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2304 :         // begin the lifetime of the array elements (e.g., before copying into them)
; 2305 : #if _HAS_CXX20
; 2306 :         if (_STD is_constant_evaluated()) {
; 2307 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2308 :                 _Bx._Buf[_Idx] = value_type();
; 2309 :             }
; 2310 :         }
; 2311 : #endif // _HAS_CXX20
; 2312 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2299 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2300 :         return _BUF_SIZE <= _Myres;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $LN3@Large_stri
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@Large_stri
$LN3@Large_stri:
	mov	DWORD PTR tv66[ebp], 0
$LN4@Large_stri:
	movzx	eax, BYTE PTR tv66[ebp]

; 2301 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2290 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2291 :         const value_type* _Result = _Bx._Buf;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR __Result$[ebp], eax

; 2292 :         if (_Large_string_engaged()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 2293 :             _Result = _Unfancy(_Bx._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	??$_Unfancy@D@std@@YAPADPAD@Z		; std::_Unfancy<char>
	add	esp, 4
	mov	DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2294 :         }
; 2295 : 
; 2296 :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2297 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2270 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2271 : 
; 2272 :     // length of internal buffer, [1, 16]:
; 2273 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2274 :     // roundup mask for allocated buffers, [0, 15]:
; 2275 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2276 :                                            : sizeof(value_type) <= 2 ? 7
; 2277 :                                            : sizeof(value_type) <= 4 ? 3
; 2278 :                                            : sizeof(value_type) <= 8 ? 1
; 2279 :                                                                      : 0;
; 2280 : 
; 2281 :     _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2282 :         value_type* _Result = _Bx._Buf;
; 2283 :         if (_Large_string_engaged()) {
; 2284 :             _Result = _Unfancy(_Bx._Ptr);
; 2285 :         }
; 2286 : 
; 2287 :         return _Result;
; 2288 :     }
; 2289 : 
; 2290 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2291 :         const value_type* _Result = _Bx._Buf;
; 2292 :         if (_Large_string_engaged()) {
; 2293 :             _Result = _Unfancy(_Bx._Ptr);
; 2294 :         }
; 2295 : 
; 2296 :         return _Result;
; 2297 :     }
; 2298 : 
; 2299 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {
; 2300 :         return _BUF_SIZE <= _Myres;
; 2301 :     }
; 2302 : 
; 2303 :     constexpr void _Activate_SSO_buffer() noexcept {
; 2304 :         // begin the lifetime of the array elements (e.g., before copying into them)
; 2305 : #if _HAS_CXX20
; 2306 :         if (_STD is_constant_evaluated()) {
; 2307 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2308 :                 _Bx._Buf[_Idx] = value_type();
; 2309 :             }
; 2310 :         }
; 2311 : #endif // _HAS_CXX20
; 2312 :     }
; 2313 : 
; 2314 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2315 :         // checks whether _Off is in the bounds of [0, size()]
; 2316 :         if (_Mysize < _Off) {
; 2317 :             _Xran();
; 2318 :         }
; 2319 :     }
; 2320 : 
; 2321 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2322 :         // checks whether _Off is in the bounds of [0, size())
; 2323 :         if (_Mysize <= _Off) {
; 2324 :             _Xran();
; 2325 :         }
; 2326 :     }
; 2327 : 
; 2328 :     [[noreturn]] static void _Xran() {
; 2329 :         _Xout_of_range("invalid string position");
; 2330 :     }
; 2331 : 
; 2332 :     _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2333 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2334 :         return (_STD min)(_Size, _Mysize - _Off);
; 2335 :     }
; 2336 : 
; 2337 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2338 :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 2339 :         // renaming `_String_val` (and fixing the visualizer).
; 2340 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 2341 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2342 : 
; 2343 :         value_type _Buf[_BUF_SIZE];
; 2344 :         pointer _Ptr;
; 2345 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2346 :     } _Bx;
; 2347 : 
; 2348 :     size_type _Mysize = 0; // current length of string

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 2349 :     size_type _Myres  = 0; // current storage reserved for string

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 2270 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 697  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 698  :         return _Al;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 699  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 693  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 694  :         return static_cast<size_t>(-1) / sizeof(value_type);

	or	eax, -1

; 695  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 832  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 833  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 834  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Get_size_of_n@$00@std@@YAII@Z	; std::_Get_size_of_n<1>
	add	esp, 4
	push	eax
	call	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
	add	esp, 4

; 835  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 826  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
$LN4@deallocate:

; 827  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN10@deallocate
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN7@deallocate
$LN10@deallocate:
	jmp	SHORT $LN2@deallocate
$LN7@deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
$LN12@deallocate:
	mov	esi, esp
	push	0
	push	827					; 0000033bH
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@deallocate
$LN2@deallocate:
	xor	eax, eax
	jne	SHORT $LN4@deallocate

; 828  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 829  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z	; std::_Deallocate<8,0>
	add	esp, 8

; 830  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 818  :     constexpr allocator() noexcept {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2366 : [[noreturn]] inline void _Xlen_string() {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 2367 :     _Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen_strin:

; 2368 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 488  :     _NODISCARD static constexpr int_type eof() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 489  :         return static_cast<int_type>(EOF);

	or	eax, -1

; 490  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 480  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-4]
	mov	ecx, 1
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 481  :         return _Left == _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@eq_int_typ
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
	mov	DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
	movzx	eax, BYTE PTR tv65[ebp]

; 482  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 455  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 456  : #if _HAS_CXX20
; 457  :         if (_STD is_constant_evaluated()) {
; 458  :             return _Primary_char_traits::assign(_Left, _Right);
; 459  :         }
; 460  : #endif // _HAS_CXX20
; 461  :         _Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 462  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 402  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 403  :         // find length of null-terminated string
; 404  : #if _HAS_CXX17
; 405  : #ifdef __cpp_char8_t
; 406  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 407  : #if _HAS_U8_INTRINSICS
; 408  :             return __builtin_u8strlen(_First);
; 409  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 410  :             return _Primary_char_traits::length(_First);
; 411  : #endif // _HAS_U8_INTRINSICS
; 412  :         } else
; 413  : #endif // __cpp_char8_t
; 414  :         {
; 415  :             return __builtin_strlen(_First);
; 416  :         }
; 417  : #else // _HAS_CXX17
; 418  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 419  : #endif // _HAS_CXX17
; 420  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 93   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 94   :             bool _Loop_forward = true;
; 95   : 
; 96   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 97   :                 if (_First1 == _Src) {
; 98   :                     _Loop_forward = false;
; 99   :                     break;
; 100  :                 }
; 101  :             }
; 102  : 
; 103  :             if (_Loop_forward) {
; 104  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 105  :                     _First1[_Idx] = _First2[_Idx];
; 106  :                 }
; 107  :             } else {
; 108  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 109  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 110  :                 }
; 111  :             }
; 112  : 
; 113  :             return _First1;
; 114  :         }
; 115  : #endif // _HAS_CXX20
; 116  : 
; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 118  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 119  : 
; 120  :         return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 121  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __8BD0505D_xstring
	call	@__CheckForDebuggerJustMyCode@4

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

	mov	eax, DWORD PTR __First1$[ebp]

; 68   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 268  :     is_nothrow_constructible_v<_Ty, _Types...>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1B16000D_xutility
	call	@__CheckForDebuggerJustMyCode@4

; 269  : #if _HAS_CXX20
; 270  :     if (_STD is_constant_evaluated()) {
; 271  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 272  :     } else
; 273  : #endif // _HAS_CXX20
; 274  :     {
; 275  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Obj$[ebp]
	push	eax
	call	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
	add	esp, 4
	push	eax
	call	??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
	add	esp, 4
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 276  :     }
; 277  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 280  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __62892210_xstddef
	call	@__CheckForDebuggerJustMyCode@4

; 281  :     return __builtin_addressof(_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 282  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1309 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1302 :     _Container_proxy* _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1309 :     _CONSTEXPR20 _Basic_container_proxy_ptr12()                       = default;

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1304 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1305 :         _Ptr = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1306 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\utility
;	COMDAT ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 652  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __9596B502_utility
	call	@__CheckForDebuggerJustMyCode@4

; 653  :     // assign _New_val to _Val, return previous _Val
; 654  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old_val$[ebp], ecx

; 655  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR __New_val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 656  :     return _Old_val;

	mov	eax, DWORD PTR __Old_val$[ebp]

; 657  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ PROC	; std::_Iterator_base12::_Orphan_me_locked_v3, COMDAT
; _this$ = ecx

; 1218 :     void _Orphan_me_locked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1219 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1220 :         _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1221 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Orphan_me_
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Orphan_me_:
	DD	1
	DD	$LN4@Orphan_me_
$LN4@Orphan_me_:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Orphan_me_
$LN3@Orphan_me_:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ENDP	; std::_Iterator_base12::_Orphan_me_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Pnext$ = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ PROC ; std::_Iterator_base12::_Orphan_me_unlocked_v3, COMDAT
; _this$ = ecx

; 1202 :     _CONSTEXPR20 void _Orphan_me_unlocked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1203 :         if (!_Myproxy) { // already orphaned

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@Orphan_me_

; 1204 :             return;

	jmp	$LN13@Orphan_me_
$LN10@Orphan_me_:

; 1205 :         }
; 1206 : 
; 1207 :         // adopted, remove self from list
; 1208 :         _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_me_:

; 1209 :         while (*_Pnext && *_Pnext != this) {

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Orphan_me_
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN6@Orphan_me_

; 1210 :             _Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$[ebp], ecx

; 1211 :         }

	jmp	SHORT $LN2@Orphan_me_
$LN6@Orphan_me_:

; 1212 : 
; 1213 :         _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN9@Orphan_me_
	jmp	SHORT $LN4@Orphan_me_
$LN9@Orphan_me_:
	mov	esi, esp
	push	OFFSET ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	push	1213					; 000004bdH
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN14@Orphan_me_
	int	3
$LN14@Orphan_me_:
	mov	esi, esp
	push	0
	push	1213					; 000004bdH
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN9@Orphan_me_
$LN4@Orphan_me_:
	xor	eax, eax
	jne	SHORT $LN6@Orphan_me_

; 1214 :         *_Pnext  = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1215 :         _Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN13@Orphan_me_:

; 1216 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ENDP ; std::_Iterator_base12::_Orphan_me_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Parent$ = 8						; size = 4
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_locked, COMDAT
; _this$ = ecx

; 1197 :     void _Adopt_locked(const _Container_base12* _Parent) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1198 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1199 :         _Adopt_unlocked(_Parent);

	mov	eax, DWORD PTR __Parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1200 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Adopt_lock
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN5@Adopt_lock:
	DD	1
	DD	$LN4@Adopt_lock
$LN4@Adopt_lock:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Adopt_lock
$LN3@Adopt_lock:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Parent$ = 8						; size = 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_unlocked, COMDAT
; _this$ = ecx

; 1180 :     _CONSTEXPR20 void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1181 :         if (!_Parent) {

	cmp	DWORD PTR __Parent$[ebp], 0
	jne	SHORT $LN2@Adopt_unlo

; 1182 :             _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1183 :             return;

	jmp	SHORT $LN5@Adopt_unlo
$LN2@Adopt_unlo:

; 1184 :         }
; 1185 : 
; 1186 :         _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Parent_proxy$[ebp], ecx

; 1187 :         if (_Myproxy != _Parent_proxy) { // change parentage

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent_proxy$[ebp]
	je	SHORT $LN5@Adopt_unlo

; 1188 :             if (_Myproxy) { // adopted, remove self from list

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Adopt_unlo

; 1189 :                 _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN4@Adopt_unlo:

; 1190 :             }
; 1191 :             _Mynextiter                 = _Parent_proxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1192 :             _Parent_proxy->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent_proxy$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1193 :             _Myproxy                    = _Parent_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Adopt_unlo:

; 1194 :         }
; 1195 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Right$ = 8						; size = 4
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z PROC	; std::_Iterator_base12::_Assign_locked, COMDAT
; _this$ = ecx

; 1175 :     void _Assign_locked(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1176 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1177 :         _Assign_unlocked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1178 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Assign_loc
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN5@Assign_loc:
	DD	1
	DD	$LN4@Assign_loc
$LN4@Assign_loc:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Assign_loc
$LN3@Assign_loc:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ENDP	; std::_Iterator_base12::_Assign_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z PROC ; std::_Iterator_base12::_Assign_unlocked, COMDAT
; _this$ = ecx

; 1163 :     _CONSTEXPR20 void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1164 :         if (_Myproxy == _Right._Myproxy) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Assign_unl

; 1165 :             return;

	jmp	SHORT $LN5@Assign_unl
$LN2@Assign_unl:

; 1166 :         }
; 1167 : 
; 1168 :         if (_Right._Myproxy) {

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Assign_unl

; 1169 :             _Adopt_unlocked(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1170 :         } else { // becoming invalid, disown current parent

	jmp	SHORT $LN5@Assign_unl
$LN3@Assign_unl:

; 1171 :             _Orphan_me_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN5@Assign_unl:

; 1172 :         }
; 1173 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ENDP ; std::_Iterator_base12::_Assign_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 1152 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1153 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getcont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@Getcont
$LN3@Getcont:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Getcont:
	mov	eax, DWORD PTR tv68[ebp]

; 1154 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 1132 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1133 : #if _HAS_CXX20
; 1134 :         if (_STD is_constant_evaluated()) {
; 1135 :             _Adopt_unlocked(_Parent);
; 1136 :         } else
; 1137 : #endif // _HAS_CXX20
; 1138 :         {
; 1139 :             _Adopt_locked(_Parent);

	mov	eax, DWORD PTR __Parent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked

; 1140 :         }
; 1141 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 1121 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1122 : #if _HAS_CXX20
; 1123 :         if (_STD is_constant_evaluated()) {
; 1124 :             _Orphan_me_unlocked_v3();
; 1125 :         } else
; 1126 : #endif // _HAS_CXX20
; 1127 :         {
; 1128 :             _Orphan_me_locked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3

; 1129 :         }
; 1130 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 1104 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1105 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1106 : #if _HAS_CXX20
; 1107 :         if (_STD is_constant_evaluated()) {
; 1108 :             _Assign_unlocked(_Right);
; 1109 :         } else
; 1110 : #endif // _HAS_CXX20
; 1111 :         {
; 1112 :             _Assign_locked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked

; 1113 :         }
; 1114 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1115 :         _Myproxy = _Right._Myproxy;
; 1116 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1117 :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1118 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1100 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1103 : 
; 1104 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1105 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1106 : #if _HAS_CXX20
; 1107 :         if (_STD is_constant_evaluated()) {
; 1108 :             _Assign_unlocked(_Right);
; 1109 :         } else
; 1110 : #endif // _HAS_CXX20
; 1111 :         {
; 1112 :             _Assign_locked(_Right);
; 1113 :         }
; 1114 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1115 :         _Myproxy = _Right._Myproxy;
; 1116 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1117 :         return *this;
; 1118 :     }
; 1119 : 
; 1120 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1121 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1122 : #if _HAS_CXX20
; 1123 :         if (_STD is_constant_evaluated()) {
; 1124 :             _Orphan_me_unlocked_v3();
; 1125 :         } else
; 1126 : #endif // _HAS_CXX20
; 1127 :         {
; 1128 :             _Orphan_me_locked_v3();
; 1129 :         }
; 1130 :     }
; 1131 : 
; 1132 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1133 : #if _HAS_CXX20
; 1134 :         if (_STD is_constant_evaluated()) {
; 1135 :             _Adopt_unlocked(_Parent);
; 1136 :         } else
; 1137 : #endif // _HAS_CXX20
; 1138 :         {
; 1139 :             _Adopt_locked(_Parent);
; 1140 :         }
; 1141 :     }
; 1142 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1143 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1144 :         if (_Parent) { // have a parent, do adoption
; 1145 :             _Myproxy = _Parent->_Myproxy;
; 1146 :         } else { // no future parent, just disown current parent
; 1147 :             _Myproxy = nullptr;
; 1148 :         }
; 1149 :     }
; 1150 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1151 : 
; 1152 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1153 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1154 :     }
; 1155 : 
; 1156 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1157 : 
; 1158 :     mutable _Container_proxy* _Myproxy    = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1159 :     mutable _Iterator_base12* _Mynextiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1101 :         *this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 1102 :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1098 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1099 : 
; 1100 :     _CONSTEXPR20 _Iterator_base12(const _Iterator_base12& _Right) noexcept {
; 1101 :         *this = _Right;
; 1102 :     }
; 1103 : 
; 1104 :     _CONSTEXPR20 _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1105 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1106 : #if _HAS_CXX20
; 1107 :         if (_STD is_constant_evaluated()) {
; 1108 :             _Assign_unlocked(_Right);
; 1109 :         } else
; 1110 : #endif // _HAS_CXX20
; 1111 :         {
; 1112 :             _Assign_locked(_Right);
; 1113 :         }
; 1114 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1115 :         _Myproxy = _Right._Myproxy;
; 1116 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1117 :         return *this;
; 1118 :     }
; 1119 : 
; 1120 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1121 :     _CONSTEXPR20 ~_Iterator_base12() noexcept {
; 1122 : #if _HAS_CXX20
; 1123 :         if (_STD is_constant_evaluated()) {
; 1124 :             _Orphan_me_unlocked_v3();
; 1125 :         } else
; 1126 : #endif // _HAS_CXX20
; 1127 :         {
; 1128 :             _Orphan_me_locked_v3();
; 1129 :         }
; 1130 :     }
; 1131 : 
; 1132 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1133 : #if _HAS_CXX20
; 1134 :         if (_STD is_constant_evaluated()) {
; 1135 :             _Adopt_unlocked(_Parent);
; 1136 :         } else
; 1137 : #endif // _HAS_CXX20
; 1138 :         {
; 1139 :             _Adopt_locked(_Parent);
; 1140 :         }
; 1141 :     }
; 1142 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1143 :     _CONSTEXPR20 void _Adopt(const _Container_base12* _Parent) noexcept {
; 1144 :         if (_Parent) { // have a parent, do adoption
; 1145 :             _Myproxy = _Parent->_Myproxy;
; 1146 :         } else { // no future parent, just disown current parent
; 1147 :             _Myproxy = nullptr;
; 1148 :         }
; 1149 :     }
; 1150 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1151 : 
; 1152 :     _CONSTEXPR20 const _Container_base12* _Getcont() const noexcept {
; 1153 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1154 :     }
; 1155 : 
; 1156 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1157 : 
; 1158 :     mutable _Container_proxy* _Myproxy    = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1159 :     mutable _Iterator_base12* _Mynextiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1098 :     _CONSTEXPR20 _Iterator_base12() noexcept = default; // construct orphaned iterator

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_locked, COMDAT
; _this$ = ecx

; 1090 :     void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1091 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1092 :         _Swap_proxy_and_iterators_unlocked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked

; 1093 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Swap_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN5@Swap_proxy:
	DD	1
	DD	$LN4@Swap_proxy
$LN4@Swap_proxy:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Swap_proxy
$LN3@Swap_proxy:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1085 :     void _Orphan_all_locked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1086 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1087 :         _Orphan_all_unlocked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1088 :     }

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Orphan_all:
	DD	1
	DD	$LN4@Orphan_all
$LN4@Orphan_all:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN3@Orphan_all
$LN3@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z
_TEXT	SEGMENT
__Temp$ = -20						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked, COMDAT
; _this$ = ecx

; 1249 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1250 :     _Container_proxy* _Temp = _Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Temp$[ebp], ecx

; 1251 :     _Myproxy                = _Right._Myproxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1252 :     _Right._Myproxy         = _Temp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Temp$[ebp]
	mov	DWORD PTR [eax], ecx

; 1253 : 
; 1254 :     if (_Myproxy) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Swap_proxy

; 1255 :         _Myproxy->_Mycont = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], edx
$LN2@Swap_proxy:

; 1256 :     }
; 1257 : 
; 1258 :     if (_Right._Myproxy) {

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Swap_proxy

; 1259 :         _Right._Myproxy->_Mycont = &_Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [ecx], edx
$LN4@Swap_proxy:

; 1260 :     }
; 1261 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators_unlocked@_Container_base12@std@@AAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
__Pnext$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1225 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1226 :     if (!_Myproxy) { // no proxy, already done

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Orphan_all

; 1227 :         return;

	jmp	SHORT $LN6@Orphan_all
$LN5@Orphan_all:

; 1228 :     }
; 1229 : 
; 1230 :     // proxy allocated, drain it
; 1231 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

	mov	DWORD PTR $T1[ebp], 0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 4
	push	edx
	call	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
	add	esp, 8
	mov	DWORD PTR __Pnext$2[ebp], eax
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnext$2[ebp], ecx
$LN4@Orphan_all:
	cmp	DWORD PTR __Pnext$2[ebp], 0
	je	SHORT $LN6@Orphan_all

; 1232 :         _Pnext->_Myproxy = nullptr;

	mov	eax, DWORD PTR __Pnext$2[ebp]
	mov	DWORD PTR [eax], 0

; 1233 :     }

	jmp	SHORT $LN2@Orphan_all
$LN6@Orphan_all:

; 1234 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z PROC ; std::_Container_base12::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 1263 : _CONSTEXPR20 void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1264 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1265 : #if _HAS_CXX20
; 1266 :     if (_STD is_constant_evaluated()) {
; 1267 :         _Swap_proxy_and_iterators_unlocked(_Right);
; 1268 :     } else
; 1269 : #endif // _HAS_CXX20
; 1270 :     {
; 1271 :         _Swap_proxy_and_iterators_locked(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Swap_proxy_and_iterators_locked@_Container_base12@std@@AAEXAAU12@@Z ; std::_Container_base12::_Swap_proxy_and_iterators_locked

; 1272 :     }
; 1273 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1274 :     _Swap_proxy_and_iterators_unlocked(_Right);
; 1275 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1276 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Swap_proxy_and_iterators@_Container_base12@std@@QAEXAAU12@@Z ENDP ; std::_Container_base12::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1236 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1237 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1238 : #if _HAS_CXX20
; 1239 :     if (_STD is_constant_evaluated()) {
; 1240 :         _Orphan_all_unlocked_v3();
; 1241 :     } else
; 1242 : #endif // _HAS_CXX20
; 1243 :     {
; 1244 :         _Orphan_all_locked_v3();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3

; 1245 :     }
; 1246 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1247 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1054 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 1055 : 
; 1056 :     _Container_base12(const _Container_base12&)            = delete;
; 1057 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1058 : 
; 1059 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1060 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1061 : 
; 1062 :     template <class _Alloc>
; 1063 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1064 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1065 :         _Construct_in_place(*_New_proxy, this);
; 1066 :         _Myproxy            = _New_proxy;
; 1067 :         _New_proxy->_Mycont = this;
; 1068 :     }
; 1069 : 
; 1070 :     template <class _Alloc>
; 1071 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1072 :         // pre: no iterators refer to the existing proxy
; 1073 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1074 :         _Construct_in_place(*_New_proxy, this);
; 1075 :         _New_proxy->_Mycont = this;
; 1076 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1077 :     }
; 1078 : 
; 1079 :     _Container_proxy* _Myproxy = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1054 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1046 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont_$[ebp]
	mov	DWORD PTR [eax], ecx

; 1047 : 
; 1048 :     const _Container_base12* _Mycont       = nullptr;
; 1049 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1046 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 145  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 146  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 147  :     _Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 39					; 00000027H
	mov	edx, DWORD PTR __Bytes$[ebp]
	mov	DWORD PTR [edx], ecx

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_user$[ebp], ecx

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr_user$[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	jne	SHORT $LN7@Adjust_man
	jmp	SHORT $LN2@Adjust_man
$LN7@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
$LN19@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 9
	push	eax
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN2@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN4@Adjust_man

; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	DWORD PTR __Min_back_shift$[ebp], 8

; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	DWORD PTR __Back_shift$[ebp], 8
	jb	SHORT $LN13@Adjust_man
	cmp	DWORD PTR __Back_shift$[ebp], 39	; 00000027H
	ja	SHORT $LN13@Adjust_man
	jmp	SHORT $LN8@Adjust_man
$LN13@Adjust_man:
	mov	esi, esp
	push	OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
	push	OFFSET ??_C@_02DKCKIIND@?$CFs@
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_0GC@FPOGKCLE@C?3?2Program?5Files?2Microsoft?5Visu@
	push	2
	call	DWORD PTR __imp___CrtDbgReport
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
$LN20@Adjust_man:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
	add	eax, 19					; 00000013H
	push	eax
	push	OFFSET ??_C@_1ME@GKDENAFF@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	push	OFFSET ??_C@_11LOCGONAA@@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
	xor	eax, eax
	jne	SHORT $LN13@Adjust_man
$LN8@Adjust_man:
	xor	eax, eax
	jne	SHORT $LN10@Adjust_man

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Ptr_container$[ebp]
	mov	DWORD PTR [eax], ecx

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 76   :         void* _Allocate(const size_t _Bytes) {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __FF03D6C1_xmemory
	call	@__CheckForDebuggerJustMyCode@4

; 77   :         return ::operator new(_Bytes);

	mov	eax, DWORD PTR __Bytes$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 78   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 552  :     _NODISCARD static constexpr int(max)() noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __7DF72CD2_limits
	call	@__CheckForDebuggerJustMyCode@4

; 553  :         return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH

; 554  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -208						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 328  : [[noreturn]] inline void _Throw_bad_array_new_length() {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-20]
	mov	ecx, 5
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __C894841B_exception
	call	@__CheckForDebuggerJustMyCode@4

; 329  :     _THROW(bad_array_new_length{});

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0bad_array_new_length@std@@QAE@XZ	; std::bad_array_new_length::bad_array_new_length
	push	OFFSET __TI3?AVbad_array_new_length@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Throw_bad_:

; 330  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_array_new_length@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DFFE99FD_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 140  :         : bad_alloc("bad array new length")

	push	OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0bad_alloc@std@@AAE@QBD@Z		; std::bad_alloc::bad_alloc

; 141  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DFFE99FD_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 129  :         : exception(_Message, 1)

	push	1
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@QBDH@Z		; std::exception::exception

; 130  :     {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-16]
	mov	ecx, 4
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DFFE99FD_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@what
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@what
$LN3@what:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
	mov	eax, DWORD PTR tv69[ebp]

; 96   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DFFE99FD_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	___std_exception_destroy
	add	esp, 4

; 91   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DFFE99FD_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR __Other$[ebp]
	add	ecx, 4
	push	ecx
	call	___std_exception_copy
	add	esp, 8

; 74   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __DFFE99FD_vcruntime_exception@h
	call	@__CheckForDebuggerJustMyCode@4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Message$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 68   :     }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\type_traits
;	COMDAT ??$_Hash_representation@M@std@@YAIABM@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??$_Hash_representation@M@std@@YAIABM@Z PROC		; std::_Hash_representation<float>, COMDAT

; 2147 : _NODISCARD size_t _Hash_representation(const _Kty& _Keyval) noexcept { // bitwise hashes the representation of a key

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1F1E5892_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2148 :     return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	push	-2128831035				; 811c9dc5H
	call	??$_Fnv1a_append_value@M@std@@YAIIABM@Z	; std::_Fnv1a_append_value<float>
	add	esp, 8

; 2149 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Hash_representation@M@std@@YAIABM@Z ENDP		; std::_Hash_representation<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\type_traits
;	COMDAT ??R?$hash@M@std@@QBEIM@Z
_TEXT	SEGMENT
tv66 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Keyval$ = 8						; size = 4
??R?$hash@M@std@@QBEIM@Z PROC				; std::hash<float>::operator(), COMDAT
; _this$ = ecx

; 2195 :     _NODISCARD size_t operator()(const float _Keyval) const noexcept {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-28]
	mov	ecx, 7
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, OFFSET __1F1E5892_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2196 :         return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); // map -0 to 0

	movss	xmm0, DWORD PTR __Keyval$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	xorps	xmm0, xmm0
	movss	DWORD PTR tv66[ebp], xmm0
	jmp	SHORT $LN4@operator
$LN3@operator:
	movss	xmm0, DWORD PTR __Keyval$[ebp]
	movss	DWORD PTR tv66[ebp], xmm0
$LN4@operator:
	movss	xmm0, DWORD PTR tv66[ebp]
	movss	DWORD PTR $T1[ebp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Hash_representation@M@std@@YAIABM@Z	; std::_Hash_representation<float>
	add	esp, 4

; 2197 :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??R?$hash@M@std@@QBEIM@Z ENDP				; std::hash<float>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\type_traits
;	COMDAT ?_Fnv1a_append_bytes@std@@YAIIQBEI@Z
_TEXT	SEGMENT
__Idx$1 = -8						; size = 4
__Val$ = 8						; size = 4
__First$ = 12						; size = 4
__Count$ = 16						; size = 4
?_Fnv1a_append_bytes@std@@YAIIQBEI@Z PROC		; std::_Fnv1a_append_bytes, COMDAT

; 2121 :     const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __1F1E5892_type_traits
	call	@__CheckForDebuggerJustMyCode@4

; 2122 :     for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

	mov	DWORD PTR __Idx$1[ebp], 0
	jmp	SHORT $LN4@Fnv1a_appe
$LN2@Fnv1a_appe:
	mov	eax, DWORD PTR __Idx$1[ebp]
	add	eax, 1
	mov	DWORD PTR __Idx$1[ebp], eax
$LN4@Fnv1a_appe:
	mov	eax, DWORD PTR __Idx$1[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@Fnv1a_appe

; 2123 :         _Val ^= static_cast<size_t>(_First[_Idx]);

	mov	eax, DWORD PTR __First$[ebp]
	add	eax, DWORD PTR __Idx$1[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$[ebp], ecx

; 2124 :         _Val *= _FNV_prime;

	imul	eax, DWORD PTR __Val$[ebp], 16777619
	mov	DWORD PTR __Val$[ebp], eax

; 2125 :     }

	jmp	SHORT $LN2@Fnv1a_appe
$LN3@Fnv1a_appe:

; 2126 : 
; 2127 :     return _Val;

	mov	eax, DWORD PTR __Val$[ebp]

; 2128 : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Fnv1a_append_bytes@std@@YAIIQBEI@Z ENDP		; std::_Fnv1a_append_bytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.35.32215\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 168  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __EBA563F3_vcruntime_new@h
	call	@__CheckForDebuggerJustMyCode@4

; 169  :         (void)_Size;
; 170  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 171  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\pch.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __BB00C2DC_pch@cpp
	call	@__CheckForDebuggerJustMyCode@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
