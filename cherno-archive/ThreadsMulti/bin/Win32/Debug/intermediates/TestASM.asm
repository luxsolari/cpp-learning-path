; Listing generated by Microsoft (R) Optimizing Compiler Version 19.35.32215.0 

	TITLE	D:\data\code\gaming-studio-practices\ThreadsMulti\bin\Win32\Debug\intermediates\TestASM.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__6857C8E5_ThreadsMulti@pch DB 01H
__86DF171F_TestASM@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?reallyNotmain@@YAHXZ				; reallyNotmain
PUBLIC	__JustMyCode_Default
PUBLIC	__real@40000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	?Q_rsqrt@@YAMM@Z:PROC				; Q_rsqrt
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\data\code\gaming-studio-practices\ThreadsMulti\src\TestASM.cpp
;	COMDAT ?reallyNotmain@@YAHXZ
_TEXT	SEGMENT
tv147 = -424						; size = 4
tv130 = -424						; size = 4
$T1 = -416						; size = 4
$T2 = -404						; size = 4
$T3 = -392						; size = 4
$T4 = -380						; size = 4
$T5 = -368						; size = 4
$T6 = -356						; size = 4
_inverseSqRoot2$ = -152					; size = 4
_inverseSqRoot$ = -140					; size = 4
_j$7 = -128						; size = 4
_i$8 = -116						; size = 4
_a1d$ = -104						; size = 4
_i$9 = -92						; size = 4
_j$10 = -80						; size = 4
_i$11 = -68						; size = 4
_i$12 = -56						; size = 4
_a2d$ = -44						; size = 4
_i$13 = -32						; size = 4
_y$ = -20						; size = 4
_x$ = -8						; size = 4
?reallyNotmain@@YAHXZ PROC				; reallyNotmain, COMDAT

; 6    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86DF171F_TestASM@cpp
	call	@__CheckForDebuggerJustMyCode@4

; 7    : 	int x {0}, y {0};	// x and y are initialized to 0. this are braced initialization. 

	mov	DWORD PTR _x$[ebp], 0
	mov	DWORD PTR _y$[ebp], 0

; 8    : 						// this kind of initialization is more efficient than the other kind of initialization.
; 9    : 						// it was introduced in C++11.
; 10   : 
; 11   : 	for (int i{0}; i < 100; i++)	// this is a for loop with braced initialization

	mov	DWORD PTR _i$13[ebp], 0
	jmp	SHORT $LN4@reallyNotm
$LN2@reallyNotm:
	mov	eax, DWORD PTR _i$13[ebp]
	add	eax, 1
	mov	DWORD PTR _i$13[ebp], eax
$LN4@reallyNotm:
	cmp	DWORD PTR _i$13[ebp], 100		; 00000064H
	jge	SHORT $LN3@reallyNotm

; 12   : 	{
; 13   : 		x += i;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _i$13[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 14   : 		y += i;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _i$13[ebp]
	mov	DWORD PTR _y$[ebp], eax

; 15   : 	}

	jmp	SHORT $LN2@reallyNotm
$LN3@reallyNotm:

; 16   : 
; 17   : 	sizeof(int*); // this returns the size of a pointer to int. 
; 18   : 				  // in 32 bit systems, this is 4 bytes. 
; 19   : 				  // in 64 bit systems, this is 8 bytes.
; 20   : 
; 21   : 	sizeof(int); // this returns the size of an int. 
; 22   : 				 // in 32 bit systems, this is 4 bytes. 
; 23   : 				 // in 64 bit systems, this is 4 bytes.
; 24   : 
; 25   : 	int** a2d = new int*[10];	// this is a 2d array with 10 pointers to int arrays. 

	push	40					; 00000028H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _a2d$[ebp], eax

; 26   : 								// (this reserves memory for the 10 pointers. the type only determines the size of the memory reserved for each row)
; 27   : 								// the size of this array is 10 * sizeof(int*) = 10 * 8 = 80 bytes
; 28   : 	for (int i{0}; i < 10; i++)

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN7@reallyNotm
$LN5@reallyNotm:
	mov	eax, DWORD PTR _i$12[ebp]
	add	eax, 1
	mov	DWORD PTR _i$12[ebp], eax
$LN7@reallyNotm:
	cmp	DWORD PTR _i$12[ebp], 10		; 0000000aH
	jge	SHORT $LN6@reallyNotm

; 29   : 	{
; 30   : 		a2d[i] = new int[10]; // this allocates memory for a new 10 element array and stores the pointer to its location. 

	push	40					; 00000028H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR _i$12[ebp]
	mov	ecx, DWORD PTR _a2d$[ebp]
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 31   : 							  // (this reserves memory for each row. the type only determines the size of the memory reserved for each element)
; 32   : 							  // the size of each row is 10 * sizeof(int) = 10 * 4 = 40 bytes
; 33   : 	}

	jmp	SHORT $LN5@reallyNotm
$LN6@reallyNotm:

; 34   : 
; 35   : 	for (int i{0}; i < 10; i++)

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN10@reallyNotm
$LN8@reallyNotm:
	mov	eax, DWORD PTR _i$11[ebp]
	add	eax, 1
	mov	DWORD PTR _i$11[ebp], eax
$LN10@reallyNotm:
	cmp	DWORD PTR _i$11[ebp], 10		; 0000000aH
	jge	SHORT $LN9@reallyNotm

; 36   : 	{
; 37   : 		for (int j{0}; j < 10; j++)

	mov	DWORD PTR _j$10[ebp], 0
	jmp	SHORT $LN13@reallyNotm
$LN11@reallyNotm:
	mov	eax, DWORD PTR _j$10[ebp]
	add	eax, 1
	mov	DWORD PTR _j$10[ebp], eax
$LN13@reallyNotm:
	cmp	DWORD PTR _j$10[ebp], 10		; 0000000aH
	jge	SHORT $LN12@reallyNotm

; 38   : 		{
; 39   : 			a2d[i][j] = i * j;	// initializing each element of the 2d array

	mov	eax, DWORD PTR _i$11[ebp]
	imul	eax, DWORD PTR _j$10[ebp]
	mov	ecx, DWORD PTR _i$11[ebp]
	mov	edx, DWORD PTR _a2d$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _j$10[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 40   : 		}

	jmp	SHORT $LN11@reallyNotm
$LN12@reallyNotm:

; 41   : 	}

	jmp	SHORT $LN8@reallyNotm
$LN9@reallyNotm:

; 42   : 	
; 43   : 	for (int i{0}; i < 10; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN16@reallyNotm
$LN14@reallyNotm:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN16@reallyNotm:
	cmp	DWORD PTR _i$9[ebp], 10			; 0000000aH
	jge	SHORT $LN15@reallyNotm

; 44   : 	{
; 45   : 		delete[] a2d[i];	// deleting each row

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _a2d$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 46   : 	}

	jmp	SHORT $LN14@reallyNotm
$LN15@reallyNotm:

; 47   : 	delete[] a2d;	// deleting the 2d array

	mov	eax, DWORD PTR _a2d$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	cmp	DWORD PTR $T3[ebp], 0
	jne	SHORT $LN24@reallyNotm
	mov	DWORD PTR tv130[ebp], 0
	jmp	SHORT $LN25@reallyNotm
$LN24@reallyNotm:
	mov	DWORD PTR _a2d$[ebp], 33059		; 00008123H
	mov	edx, DWORD PTR _a2d$[ebp]
	mov	DWORD PTR tv130[ebp], edx
$LN25@reallyNotm:

; 48   : 
; 49   : 
; 50   : 	// all of the above can be done with a 1-dimensional array:
; 51   : 	int* a1d = new int[10 * 10];	// this is a 1d array with 100 elements. 

	push	400					; 00000190H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _a1d$[ebp], eax

; 52   : 									// (this reserves memory for the 100 elements. the type only determines the size of the memory reserved for each element)
; 53   : 									// the size of this array is 100 * sizeof(int) = 100 * 4 = 400 bytes
; 54   : 
; 55   : 	for (int i{0}; i < 10; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN19@reallyNotm
$LN17@reallyNotm:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN19@reallyNotm:
	cmp	DWORD PTR _i$8[ebp], 10			; 0000000aH
	jge	SHORT $LN18@reallyNotm

; 56   : 	{
; 57   : 		for (int j{0}; j < 10; j++)

	mov	DWORD PTR _j$7[ebp], 0
	jmp	SHORT $LN22@reallyNotm
$LN20@reallyNotm:
	mov	eax, DWORD PTR _j$7[ebp]
	add	eax, 1
	mov	DWORD PTR _j$7[ebp], eax
$LN22@reallyNotm:
	cmp	DWORD PTR _j$7[ebp], 10			; 0000000aH
	jge	SHORT $LN21@reallyNotm

; 58   : 		{
; 59   : 			a1d[i * 10 + j] = i * j;	// initializing each element of the 1d array

	mov	eax, DWORD PTR _i$8[ebp]
	imul	eax, DWORD PTR _j$7[ebp]
	imul	ecx, DWORD PTR _i$8[ebp], 10
	add	ecx, DWORD PTR _j$7[ebp]
	mov	edx, DWORD PTR _a1d$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 60   : 		}

	jmp	SHORT $LN20@reallyNotm
$LN21@reallyNotm:

; 61   : 	}

	jmp	SHORT $LN17@reallyNotm
$LN18@reallyNotm:

; 62   : 
; 63   : 	delete[] a1d;	// deleting the 1d array

	mov	eax, DWORD PTR _a1d$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	cmp	DWORD PTR $T1[ebp], 0
	jne	SHORT $LN26@reallyNotm
	mov	DWORD PTR tv147[ebp], 0
	jmp	SHORT $LN27@reallyNotm
$LN26@reallyNotm:
	mov	DWORD PTR _a1d$[ebp], 33059		; 00008123H
	mov	edx, DWORD PTR _a1d$[ebp]
	mov	DWORD PTR tv147[ebp], edx
$LN27@reallyNotm:

; 64   : 
; 65   : 
; 66   : 	// Handling multi-dimensional arrays in a single contigous array is called row-major order.
; 67   : 	// The first index is the row, and the second index is the column.
; 68   : 	// This is more efficient in terms of speed and memory usage, because the memory is allocated in a single contigous block.
; 69   : 	// This reduces the number of memory allocations and deallocations, and also reduces the number of cache misses.
; 70   : 	 
; 71   : 	float inverseSqRoot = Q_rsqrt(2.0f); // this is a function call. 

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	?Q_rsqrt@@YAMM@Z			; Q_rsqrt
	add	esp, 4
	fstp	DWORD PTR _inverseSqRoot$[ebp]

; 72   : 										 // the function is defined in src\InvFastSqrt.cpp
; 73   : 	float inverseSqRoot2 = Q_rsqrt(2.0f); // this is a function call. 

	push	ecx
	movss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR [esp], xmm0
	call	?Q_rsqrt@@YAMM@Z			; Q_rsqrt
	add	esp, 4
	fstp	DWORD PTR _inverseSqRoot2$[ebp]

; 74   : 										  // the function is defined in src\InvFastSqrt.cpp
; 75   : 
; 76   : 	return 0;

	xor	eax, eax

; 77   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 424				; 000001a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?reallyNotmain@@YAHXZ ENDP				; reallyNotmain
_TEXT	ENDS
END
